repo,sha,author,date,message,additions,deletions,total_changes
facebook/react,97cdd5d3c33eda77be4f96a43f72d6916d3badbb,Jordan Brown,2025-07-10T20:51:12Z,"[eslint] Do not allow useEffectEvent fns to be called in arbitrary closures (#33544)  Summary:  useEffectEvent is meant to be used specifically in combination with useEffect, and using the feature in arbitrary closures can lead to surprising reactivity semantics. In order to minimize risk in the experimental rollout, we are going to restrict its usage to being called directly inside an effect or another useEffectEvent, effectively enforcing the function coloring statically. Without an effect system this is the best we can do.",78,70,148
facebook/react,eb7f8b42c92ed804bbf7f700d2bdda276d591007,Sebastian Markbåge,2025-07-10T20:22:44Z,[Flight] Add Separate Outgoing Debug Channel (#33754)  This lets us pass a writable on the server side and readable on the client side to send debug info through a separate channel so that it doesn't interfere with the main payload as much. The main payload refers to chunks defined in the debug info which means it's still blocked on it though. This ensures that the debug data has loaded by the time the value is rendered so that the next step can forward the data.  This will be a bit fragile to race conditions until #33665 lands. Another follow up needed is the ability to skip the debug channel on the receiving side. Right now it'll block forever if you don't provide one since we're blocking on the debug data.,997,240,1237
facebook/react,eed25607629f5e67f13f53e91edec12b3388559f,Sebastian Markbåge,2025-07-10T20:16:57Z,[Flight] Treat empty message as a close signal (#33756)  We typically treat an empty message as closing the debug channel stream but for the Noop renderer we don't use an intermediate stream but just pass the message through.   https://github.com/facebook/react/blob/bbc13fa17be8eebef3e6ee47f48c76c0c44e2f36/packages/react-server-dom-webpack/src/client/ReactFlightDOMClientBrowser.js#L59-L60  For that simple case we should just treat it as a close without an intermediate stream.,4,0,4
facebook/react,463b808176ad7c9429a4981bb45a1da225fd4b85,Josh Story,2025-07-10T19:12:09Z,[Fizz] Reset the segent id assignment when postponing the root (#33755)  When postponing the root we encode the segment Id into the postponed state but we should really be reseting it to zero so we can restart the counter from the beginning when the resume is actually just a re-render.  This also no longer assigns the root segment id based on the postponed state when resuming the root for the same reason. In the future we may use the embedded replay segment id if we implement resuming the root without re-rendering everything but that is not yet implemented or planned.,12,9,21
facebook/react,96c61b7f1f145b9fe5103051b636959cdeb20cc8,Joseph Savona,2025-07-10T05:24:20Z,"[compiler] Add CompilerError.UnsupportedJS variant (#33750)  We use this variant for syntax we intentionally don't support: with statements, eval, and inline class declarations.  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33750). * #33753 * #33752 * #33751 * __->__ #33750 * #33748",22,11,33
facebook/react,0bfa404bacbad78af5b39c080ba67535f2e53044,Joseph Savona,2025-07-10T05:24:07Z,"[compiler] More precise errors for invalid import/export/namespace statements (#33748)  import, export, and TS namespace statements can only be used at the top-level of a module, which is enforced by parsers already. Here we add a backup validation of that. As of this PR, we now have only major statement type (class declarations) listed as a todo.  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33748). * #33753 * #33752 * #33751 * #33750 * __->__ #33748",36,21,57
facebook/react,81e1ee7476a68fdf13c63d3002e5ef1b699b6842,Joseph Savona,2025-07-10T05:21:02Z,"[compiler] Support inline enums (flow/ts), type declarations (#33747)  Supports inline enum declarations in both Flow and TS by treating the node as pass-through (enums can't capture values mutably). Related, this PR extends the set of type-related declarations that we ignore. Previously we threw a todo for things like DeclareClass or DeclareVariable, but these are type related and can simply be dropped just like we dropped TypeAlias.  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33747). * #33753 * #33752 * #33751 * #33750 * #33748 * __->__ #33747",179,17,196
facebook/react,4a3ff8eed65f96cda7617150f92de3544d5ddf6a,Joseph Savona,2025-07-10T05:18:30Z,"[compiler] Errors for eval(), with statments, class declarations (#33746)  * Error for `eval()` * More specific error message for `with (expr) { ... }` syntax * More specific error message for class declarations  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33746). * #33752 * #33751 * #33750 * #33748 * #33747 * __->__ #33746",73,4,77
facebook/react,ec4374c3872b320af60f322289c30cd3d7066bdf,Joseph Savona,2025-07-09T16:22:49Z,"[compiler] Show logged errors in playground (#33740)  In playground it's helpful to show all errors, even those that don't completely abort compilation. For example, to help demonstrate that the compiler catches things like setState in effects. This detects these errors and ensures we show them.",11,1,12
facebook/react,60b5271a9ad0e9eec2489b999ce774d39d09285b,Sebastian Markbåge,2025-07-09T14:43:56Z,[Flight] Call finishHaltedTask on sync aborted tasks in stream abort listeners (#33743)  This is the same as we do for currently rendering tasks. They get effectively sync aborted when the listener is invoked.  We potentially miss out on some debug info in that case but that would only apply to any entries inside the stream which doesn't really have their own debug info anyway.,6,2,8
facebook/react,033edca72199f5b0dac87e4662b6a4d32a9610ce,Sebastian Markbåge,2025-07-09T14:39:08Z,"[Flight] Yolo Retention of Promises (#33737)  Follow up to #33736.  If we need to save on CPU/memory pressure, we can instead just pray and hope that a Promise doesn't get garbage collected before we need to read it.  This can cause fragile access to the Promise value in devtools especially if it's a slow and pressured render.  Basically, you'd have to hope that GC doesn't run after the inner await finishes its microtask callback and before the resolution of the component being rendered is invoked.",1,45,46
facebook/react,e6dc25daea3d949fa5eae3bdffb8b6b79e30fc82,Sebastian Markbåge,2025-07-09T13:08:27Z,"[Flight] Always defer Promise values if they're not already resolved (#33742)  If we have the ability to lazy load Promise values, i.e. if we have a debug channel, then we should always use it for Promises that aren't already resolved and instrumented.  There's little downside to this since they're async anyway.  This also lets us avoid adding `.then()` listeners too early. E.g. if adding the listener would have side-effect. This avoids covering up ""unhandled rejection"" errors. Since if we listen to a promise eagerly, including reject listeners, we'd have marked that Promise's rejection as handled where as maybe it wouldn't have been otherwise.  In this mode we can also indefinitely wait for the Promise to resolve instead of just waiting a microtask for it to resolve.",83,2,85
facebook/react,150f022444466266bc09302b8fd47c3e4ce4d791,Sebastian Markbåge,2025-07-09T13:08:09Z,"[Flight] Ignore async stack frames when determining if a Promise was created from user space (#33739)  We use the stack of a Promise as the start of the I/O instead of the actual I/O since that can symbolize the start of the operation even if the actual I/O is batched, deduped or pooled. It can also group multiple I/O operations into one.  We want the deepest possible Promise since otherwise it would just be the Component's Promise.  However, we don't really need deeper than the boundary between first party and third party. We can't just take the outer most that has third party things on the stack though because third party can have callbacks into first party and then we want the inner one. So we take the inner most Promise that depends on I/O that has a first party stack on it.  The realization is that for the purposes of determining whether we have a first party stack we need to ignore async stack frames. They can appear on the stack when we resume third party code inside a resumption frame of a first party stack.  <img width=""832"" alt=""Screenshot 2025-07-08 at 6 34 25 PM"" src=""https://github.com/user-attachments/assets/1636f980-be4c-4340-ad49-8d2b31953436"" />  ---------  Co-authored-by: Sebastian Sebbie Silbermann <sebastian.silbermann@vercel.com>",286,5,291
facebook/react,49ded1d12a4c2771f4fa6e4592de2f97184700a9,Sebastian Markbåge,2025-07-09T13:07:06Z,[Flight] Optimize Retention of Weak Promises Abit (#33736)  We don't really need to retain a reference to whatever Promise another Promise was created in. Only awaits need to retain both their trigger and their previous context.,43,23,66
facebook/react,3a43e72d665af98b62d9c3c54bd288597dd27e6e,Sebastian Markbåge,2025-07-09T13:06:55Z,"[Flight] Create a fast path parseStackTrace which skips generating a string stack (#33735)  When we know that the object that we pass in is immediately parsed, then we know it couldn't have been reified into a unstructured stack yet. In this path we assume that we'll trigger `Error.prepareStackTrace`.  Since we know that nobody else will read the stack after us, we can skip generating a string stack and just return empty. We can also skip caching.",46,14,60
facebook/react,8ba3501cd9c982676fab35f1c8092302060d728c,Sebastian Markbåge,2025-07-09T01:47:33Z,"[Flight] Don't dedupe references to deferred objects (#33741)  If we're about to defer an object, then we shouldn't store a reference to it because then we can end up deduping by referring to the deferred string. If in a different context, we should still be able to emit the object.",6,0,6
facebook/react,956d770adf59e1f8a00a7b7c52b5727ef9e353e7,Joseph Savona,2025-07-08T23:36:57Z,"[compiler] Improve IIFE inlining (#33726)  We currently inline IIFEs by creating a temporary and a labeled block w the original code. The original return statements turn into an assignment to the temporary and break out of the label. However, many cases of IIFEs are due to inlining of manual `useMemo()`, and these cases often have only a single return statement. Here, the output is cleaner if we avoid the temporary and label - so that's what we do in this PR.  Note that the most complex part of the change is actually around ValidatePreserveExistingMemo - we have some logic to track the IIFE temporary reassignmetns which needs to be updated to handle the simpler version of inlining.  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33726). * __->__ #33726 * #33725",1126,1269,2395
facebook/react,d35fef9e21100463b0bfecb975e9d9eca45c963f,Joseph Savona,2025-07-08T23:36:47Z,"[compiler] Fix for consecutive DCE'd branches with phis (#33725)  This is an optimized version of @asmjmp0's fix in https://github.com/facebook/react/pull/31940. When we merge consecutive blocks we need to take care to rewrite later phis whose operands will now be different blocks due to merging. Rather than iterate all the blocks on each merge as in #31940, we can do a single iteration over all the phis at the end to fix them up.  Note: this is a redo of #31959  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33725). * #33726 * __->__ #33725",83,0,83
facebook/react,a7a116577daf3b135c226ed9db8a8c2f9166c023,Sebastian Markbåge,2025-07-08T17:02:29Z,[Flight] Don't track Promise stack if there's no owner (#33734)  This is a compromise because there can be a lot of Promise instances created. They're useful because they generally provide a better stack when batching/pooled connections are used.  This restores stack collection for I/O nodes so we have something to fallback on if there's no owner.  That way we can at least get a name or something out of I/O that was spawned outside a render but mostly avoids collecting starting I/O outside of render.,10,7,17
facebook/react,777264b4ef52797f63d0ed3e9e21b66b7ae6780e,Sebastian Markbåge,2025-07-08T16:54:29Z,"[Flight] Fix stack getting object limited (#33733)  Because the object limit is unfortunately depth first due to limitations of JSON stringify, we need to ensure that things we really don't want outlined are first in the enumeration order.  We add the stack length to the object limit to ensure that the stack frames aren't outlined. In console all the user space arguments are at the end of the args. In server component props, the props are at the end of the properties of the element.  For the `value` of I/O we had it before the stack so it could steal the limit from the stack. The fix is to put it at the end.",4,4,8
facebook/react,befc1246b07a04b401bc6e914b7f336a442dca1a,Josh Story,2025-07-08T15:20:12Z,[Fizz] Render preamble eagerly (#33730)  We unnecessarily render the preamble in a task. This updates the implementation to perform this render inline.  Testing this is tricky because one of the only ways you could assert this was even happening is based on how things error if you abort while rendering the root.  While adding a test for this I discovered that not all abortable tasks report errors when aborted during a normal render. I've asserted the current behavior and will address the other issue at another time and updated the assertion later as necessary,114,24,138
facebook/react,bbea677b77ebf5d696623e2f634c69744eaf9d86,Sebastian Markbåge,2025-07-08T14:49:25Z,"[Flight] Lazy load objects from the debug channel (#33728)  When a debug channel is available, we now allow objects to be lazily requested though the debug channel and only then will the server send it.  The client will actually eagerly ask for the next level of objects once it parses its payload. That way those objects have likely loaded by the time you actually expand that deep e.g. in the console repl. This is needed since the console repl is synchronous when you ask it to invoke getters.  Each level is lazily parsed which means that we don't parse the next level even though we eagerly loaded it. We parse it once the getter is invoked (in Chrome DevTools you have to click a little `(...)` to invoke the getter). When the getter is invoked, the chunk is initialized and parsed. This then causes the next level to be asked for through the debug channel. Ensuring that if you expand one more level you can do so synchronously.  Currently debug chunks are eagerly parsed, which means that if you have things like server component props that are lazy they can end up being immediately asked for, but I'm trying to move to make the debug chunks lazy.",115,4,119
facebook/react,f1ecf82bfb5fdfa5d1c3aedcf114415fc29bd2da,Sebastian Markbåge,2025-07-08T14:49:08Z,"[Flight] Optimize Async Stack Collection (#33727)  We need to optimize the collection of debug info for dev mode. This is an incredibly hot path since it instruments all I/O and Promises in the app.  These optimizations focus primarily on the collection of stack traces. They are expensive to collect because we need to eagerly collect the stacks since they can otherwise cause memory leaks. We also need to do some of the processing of them up front. We also end up only using a few of them in the end but we don't know which ones we'll use.  The first compromise here is that I now only collect the stacks of ""awaits"" if they were in a specific request's render. In some cases it's useful to collect them even outside of this if they're part of a sequence that started early. I still collect stacks for the created Promises outside of this though which can still provide some context.  The other optimization to awaits, is that since we'll only use the inner most one that had an await directly in userspace, we can stop collecting stacks on a chain of awaits after we find one. This requires a quick filter on a single callsite to determine. Since we now only collect stacks from awaits that belongs to a specific Request we can use that request's specific filter option. Technically this might not be quite correct if that same thing ends up deduped across Requests but that's an edge case.  Additionally, I now stop collecting stack for I/O nodes. They're almost always superseded by the Promise that wraps them anyway. Even if you write mostly Promise free code, you'll likely end up with a Promise at the root of the component eventually anyway and then you end up using its stack anyway. You have to really contort the code to end up with zero Promises at which point it's not very useful anyway. At best it's maybe mostly useful for giving a name to the I/O when the rest is just stuff like `new Promise`.  However, a possible alternative optimization could be to *only* collect the stack of spawned I/O and not the stack of Promises. The issue with Promises (not awaits) is that we never know what will end up resolving them in the end when they're created so we have to always eagerly collect stacks. This could be an issue when you have a lot of abstractions that end up not actually be related to I/O at all. The issue with collecting stacks only for I/O is that the actual I/O can be pooled or batched so you end up not having the stack when the conceptual start of each operation within the batch started. Which is why I decided to keep the Promise stack.",237,195,432
facebook/react,b44a99bf58d69d52b5288d9eadcc6d226d705e11,Sebastian Markbåge,2025-07-08T04:00:00Z,"[Fiber] Name content inside ""Suspense fallback"" (#33724)  Same as #33723 but for Fiber.",43,3,46
facebook/react,e4314a0a0f6ea1ab8f739c9119583d148c1be657,Ricky,2025-07-07T17:58:03Z,[tests] Assert on component stack for Maximum Update error (#33686)  Good to assert these include the component stack,72,7,79
facebook/react,e43986f1f3e6e94f7eef86fb21c830959e0ade6c,Ricky,2025-07-07T17:57:51Z,Finally remove favorSafetyOverHydrationPerf (#33619)  This is rolled out to 100%.  Let me merge it though.,35,373,408
facebook/react,c932e457800f077352b1b322f14a796e589299fb,Sebastian Markbåge,2025-07-07T17:48:33Z,"[Fizz] Name content inside ""Suspense fallback"" (#33723)  Content in Suspense fallbacks are really not considered part of the Suspense but since it does have some behavior it should be marked somehow separately from the Suspense content.  A follow up would be to do the same in Fiber.",74,6,80
facebook/react,223f81d87728cdc843baa4fc5704c2f3b66fbd45,Sebastian Markbåge,2025-07-07T15:42:30Z,"[Flight] Flush performance track once we have no more pending chunks (#33719)  Stacked on #33718. Alternative to #33716.  The issue with flushing the Server Components track in its current form is that we need to decide how long to wait before flushing whatever we have. That's because the root's end time will be determined by the end time of that last child.  However, if a child isn't actually used then we don't necessarily need to include it in the Server Components track since it wasn't blocking the initial render.  This waits for 100ms after the last pending chunk is resolved and if nothing is invoking any more lazy initializers after that then we log the Server Components track with the information we have at that point. We also don't eagerly initialize any chunks that wasn't already initialized so if nothing was rendered, then nothing will be logged.  This is somewhat an artifact of the current visualization. If we did another transposed form we wouldn't necessarily need to wait until the end and can log things as they're discovered.",31,20,51
facebook/react,8a6c589be74a389e62a996e74f8777ccd2a237ac,Sebastian Markbåge,2025-07-07T15:42:20Z,[Flight] Keep a separate ref count for debug chunks (#33717)  Same as #33716 but without the separate close signal.  We'll need the ref count for separate debug channel anyway but I'm not sure we'll need the separate close signal.,47,55,102
facebook/react,7cafeff340f44fff840b332d3463533dc2d3734b,Sebastian Markbåge,2025-07-07T15:28:15Z,"[Flight] Close Debug Channel when All Lazy References Have Been GC:ed (#33718)  When we have a debug channel open that can ask for more objects. That doesn't close until all lazy objects have been explicitly asked for. If you GC an object before the lazy references inside of it before asking for or releasing the objects, then it'll never close.  This ensures that if there are no more PendingChunk and no more ResolvedModelChunk then we can close the connection.  There's two sources of retaining the Response object. On one side we have a handle to it from the stream coming from the server. On the other side we have a handle to it from ResolvedModelChunk to ask for more data when we lazily parse a model.  This PR makes a weak handle from the stream to the Response. However, it keeps a strong reference alive whenever we're waiting on a pending chunk because then the stream might be the root if the only listeners are the callbacks passed to the promise and no references to the promise itself.  The pending chunks count can end up being zero even if we might get more data because the references might be inside lazy chunks. In this case the lazy chunks keeps the Response alive. When the lazy chunk gets parsed it can find more chunks that then end up pending to keep the response strongly alive until they resolve.",209,52,261
facebook/react,0378b46e7e4c5c15ac57308e2894b6d78d5fb488,Sebastian Markbåge,2025-07-07T14:33:27Z,"[Flight] Include I/O not awaited in user space (#33715)   If I/O is not awaited in user space in a ""previous"" path we used to just drop it on the floor. There's a few strategies we could apply here. My first commit just emits it without an await but that would mean we don't have an await stack when there's no I/O in a follow up.  I went with a strategy where the ""previous"" I/O is used only if the ""next"" didn't have I/O. This may still drop I/O on the floor if there's two back to back within internals for example. It would only log the first one even though the outer await may have started earlier.  It may also log deeper in the ""next"" path if that had user space stacks and then the outer await will appear as if it awaited after.  So it's not perfect.",393,251,644
facebook/react,bb402876f7413ae2e6809ad442405a5a90c69b45,"Sebastian ""Sebbie"" Silbermann",2025-07-07T11:51:53Z,[Flight] Pass line/column to `filterStackFrame` (#33707),27,6,33
facebook/react,9a645e1d1027962047d2b6b26af12357203784c9,Sebastian Markbåge,2025-07-06T21:05:15Z,"[Flight] Ignore ""new Promise"" and async_hooks even if they're not ignore listed (#33714)  These are part of the internals of Promises and async functions even if anonymous functions are otherwise not ignore listed.",5,5,10
facebook/react,2d7f0c425902d13617f5c02c1b7c0f2cd95cd6d9,Sebastian Markbåge,2025-07-06T19:34:36Z,"[Flight] Insert an extra await node for awaiting on the promise returned by then callback (#33713)  When a `.then()` callback returns another Promise, there's effectively another ""await"" on that Promise that happens in the internals but that was not modeled. In effect the Promise returned by `.then()` is blocked on both the original Promise AND the promise returned by the callback.  This models that by cloning the original node and treat that as the await on the original Promise. Then we use the existing Node to await the new Promise but its ""previous"" points to the clone. That way we have a forked node that awaits both.  ---------  Co-authored-by: Sebastian Sebbie Silbermann <sebastian.silbermann@vercel.com>",194,3,197
facebook/react,4aad5e45bafe213cf2993614633d5f8d22d5d793,"Sebastian ""Sebbie"" Silbermann",2025-07-06T07:45:43Z,[Flight] Consistent format of virtual `rsc:` sources (#33706),10,4,14
facebook/react,453a19a107d02dbcde1f722361918db24426de64,Sebastian Markbåge,2025-07-05T21:01:41Z,[Flight] Collect Debug Info from Rejections in Aborted Render (#33708)  This delays the abort by splitting the abort into a first step that just flags a task as abort and tracks the time that we aborted. This first step also invokes the `cacheSignal()` abort handler.  Then in a macrotask do we finish flushing the abort (or halt). This ensures that any microtasks after the abort signal can finish flushing which may emit rejections or fulfill (e.g. if you try/catch the abort or if it was allSettled). These rejections are themselves signals for which promise was blocked on what promise which forms a graph that we can use for debug info. Notably this doesn't include any additional data in the output since we don't include any data produced after the abort. It just uses the additional execution to collect more debug info.  The abort itself might not have been spawned from I/O but it's still interesting to mark Promises that aborted as interesting since they may have been blocked on I/O. So we take the inner most Promise that resolved after the end time (presumably due to the abort signal but also could've just finished after but that's still after the abort).  Since the microtasks can spawn new Promises after the ones that reject we ignore any of those that started after the abort.,296,45,341
facebook/react,5d87cd224452c68d09bef99656b6261e9772a210,Ruslan Lesiutin,2025-07-04T15:31:00Z,"React DevTools 6.1.4 -> 6.1.5 (#33702)  Same as 6.1.4, but with 2 hotfixes: * fix: check if profiling for all profiling hooks ([hoxyq](https://github.com/hoxyq) in [#33701](https://github.com/facebook/react/pull/33701)) * fix: fallback to reading string stack trace when failed ([hoxyq](https://github.com/hoxyq) in [#33700](https://github.com/facebook/react/pull/33700))",17,10,27
facebook/react,5f71eed2ebade22ffd374d291b2a21d94c35ffa7,Ruslan Lesiutin,2025-07-04T15:21:51Z,"[devtools] fix: check if profiling for all profiling hooks (#33701)  Follow-up to https://github.com/facebook/react/pull/33652.  Don't know how the other were missed. Double-checked that Profiler works in dev mode.  Now all hooks start with `!isProfiling` check and return, if true.",328,292,620
facebook/react,455424dbf3d46d7e9326a64409de063e8f768848,Ruslan Lesiutin,2025-07-04T14:36:52Z,[devtools] fix: fallback to reading string stack trace when failed (#33700)  Discovered while testing with Hermes.,8,1,9
facebook/react,9fd4c09d6887ccd5d8a6fe69673cd89338172b5f,Ruslan Lesiutin,2025-07-04T11:55:53Z,React DevTools 6.1.3 -> 6.1.4 (#33699)  Changes from 6.1.3: * feat: static Components panel layout ([hoxyq](https://github.com/hoxyq) in [#33696](https://github.com/facebook/react/pull/33696)) * fix: support optionality of structured stack trace function name ([hoxyq](https://github.com/hoxyq) in [#33697](https://github.com/facebook/react/pull/33697)) * fix: rename bottom stack frame ([hoxyq](https://github.com/hoxyq) in [#33680](https://github.com/facebook/react/pull/33680)),17,10,27
facebook/react,d45db667d4509a5d82d4509e4aa51fdb266aa136,Ruslan Lesiutin,2025-07-04T11:29:19Z,"feat: static Components panel layout (#33696)  ## Summary  Follow-up to https://github.com/facebook/react/pull/33517.  With https://github.com/facebook/react/pull/33517, we now preserve at least some minimal indent. This actually doesn't work with the current setup, because we don't allow the container to overflow, so basically deeply nested elements will go off the screen.  With these changes, we completely change the approach: - The layout will be static and it will have a constant indentation that will always be preserved. - The container will allow overflows, so users will be able to scroll horizontally and vertically. - We will implement automatic horizontal and vertical scrolls, if selected element is not in a viewport. - New: added vertical delimiter that can be used for simpler visual navigation.  ## Demo ### Current public release  https://github.com/user-attachments/assets/58645d42-c6b8-408b-b76f-95fb272f2e1e  ### With https://github.com/facebook/react/pull/33517   https://github.com/user-attachments/assets/845285c8-5a01-4739-bcd7-ffc089e771bf  ### This PR  https://github.com/user-attachments/assets/72086b84-8d84-4626-94b3-e22e114e028e",214,305,519
facebook/react,3fc1bc6f28bec1742b5f07d23148f25927e21d41,Ruslan Lesiutin,2025-07-04T09:32:09Z,[devtools] fix: support optionality of structured stack trace function name (#33697)  Follow-up to https://github.com/facebook/react/pull/33680.  Turns out `.getFunctionName` not always returns string.,3,2,5
facebook/react,ef8b6fa257aba6c4a07b5cdb152859704aa045bc,Sebastian Markbåge,2025-07-02T22:22:14Z,"[Flight] Don't double badge consoles that are replayed from a third party (#33685)  If a FlightClient runs inside a FlightServer like fetching from a third party and that logs, then we currently double badge them since we just add on another badge. The issue is that this might be unnecessarily noisy but we also transfer the original format of the current server into the second badge.  This extracts our own badge and then adds the environment name as structured data which lets the client decide how to format it.  Before:  <img width=""599"" alt=""Screenshot 2025-07-02 at 2 30 07 PM"" src=""https://github.com/user-attachments/assets/4bf26a29-b3a8-4024-8eb9-a3f90dbff97a"" />  After:  <img width=""590"" alt=""Screenshot 2025-07-02 at 2 32 56 PM"" src=""https://github.com/user-attachments/assets/f06bbb6d-fbb1-4ae6-b0e3-775849fe3c53"" />",202,3,205
facebook/react,0b78161d7d76b7fb9786f25dd222010b9e417191,Sebastian Markbåge,2025-07-02T21:33:07Z,"[Fiber] Highlight a Component with Deeply Equal Props in the Performance Track (#33660)  Stacked on #33658 and #33659.  If we detect that a component is receiving only deeply equal objects, then we highlight it as potentially problematic and worth looking into.  <img width=""1055"" alt=""Screenshot 2025-06-27 at 4 15 28 PM"" src=""https://github.com/user-attachments/assets/e96c6a05-7fff-4fd7-b59a-36ed79f8e609"" />  It's fairly conservative and can bail out for a number of reasons:  - We only log it on the first parent that triggered this case since other children could be indirect causes. - If children has changed then we bail out since this component will rerender anyway. This means that it won't warn for a lot of cases that receive plain DOM children since the DOM children won't themselves get logged. - If the component's total render time including children is 100ms or less then we skip warning because rerendering might not be a big deal. - We don't warn if you have shallow equality but could memoize the JSX element itself since we don't typically recommend that and React Compiler doesn't do that. It only warns if you have nested objects too. - If the depth of the objects is deeper than like the 3 levels that we print diffs for then we wouldn't warn since we don't know if they were equal (although we might still warn on a child). - If the component had any updates scheduled on itself (e.g. setState) then we don't warn since it would rerender anyway. This should really consider Context updates too but we don't do that atm. Technically you should still memoize the incoming props even if you also had unrelated updates since it could apply to deeper bailouts.",84,7,91
facebook/react,dcf83f7c2db2de64ec370df73294cedb658bd896,Sebastian Markbåge,2025-07-02T21:01:49Z,"Disable ScrollTimeline in Safari (#33499)  Stacked on #33501.  This disables the use of ScrollTimeline when detected in Safari in the recommended SwipeRecognizer approach. I'm instead using a polyfill using touch events on iOS.  Safari seems set to [release ScrollTimeline soon](https://webkit.org/blog/16993/news-from-wwdc25-web-technology-coming-this-fall-in-safari-26-beta/). Unfortunately it's not really what you'd expect.  First of all, [it's not running in sync with the scroll](https://bugs.webkit.org/show_bug.cgi?id=288402) which is kind of its main point. Instead, it is running at 60fps and out of sync with the scroll just like JS. In fact, it is worse than JS because with JS you can at least spawn CSS animations that run at 120fps. So our polyfill can respond to touches at 60fps while gesturing and then run at 120fps upon release. That's better than with ScrollTimeline.  Second, [there's a bug which interrupts scrolling if you start a ViewTransition](https://bugs.webkit.org/show_bug.cgi?id=288795) when the element is being removed as part of that. The element can still respond to touches so in a polyfill this isn't an issue. But it essentially makes it useless to use ScrollTimeline with swipe-away gestures.  So we're better off in every scenario by not using it.  The UA detection is a bit unfortunate. Not sure if there's something more specific but we also had to do a UA detection for Chrome for View Transitions. Those are the only two we have in all of React.   ![safarimeme](https://github.com/user-attachments/assets/d4ca9eba-489e-4ade-b462-2ffeee3a470c)",77,11,88
facebook/react,94fce500bcd314ea19c5c89c6385be6e62397c09,Sebastian Markbåge,2025-07-02T20:12:37Z,"[Flight] Use a heuristic to extract a useful description of I/O from the Promise value (#33662)  It's useful to be able to distinguish between different invocations of common helper libraries (like fetch) without having to click through each one.  This adds a heuristic to extract a useful description of I/O from the Promise value. We try to find things like getUser(id) -> User where User.id is the id or fetch(url) -> Response where Response.url is the url.  For urls we use the filename (or hostname if there is none) as the short name if it can fit. The full url is in the tooltip.  <img width=""845"" alt=""Screenshot 2025-06-27 at 7 58 20 PM"" src=""https://github.com/user-attachments/assets/95f10c08-13a8-449e-97e8-52f0083a65dc"" />",160,29,189
facebook/react,508f7aa78ff53d058ee1151505efd5c4a4aefa01,Sebastian Markbåge,2025-07-02T20:10:52Z,"[Fiber] Switch back to using performance.measure for trigger logs (#33659)  Stacked on #33658.  Unfortunately `console.timeStamp` has the same bug that `performance.measure` used to have where equal start/end times stack in call order instead of reverse call-order. We rely on that in general so we should really switch back all.  But there is one case in particular where we always add the same start/time and that's for the ""triggers"" - Mount/Unmount/Reconnect/Disconnect. Switching to `console.timeStamp` broke this because they now showed below the thing that mounted.  After:  <img width=""726"" alt=""Screenshot 2025-06-27 at 3 31 16 PM"" src=""https://github.com/user-attachments/assets/422341c8-bef6-4909-9403-933d76b71508"" />  Also fixed a bug where clamped update times could end up logging zero width entries that stacked up on top of each other causing a two row scheduler lane which should always be one row.",24,32,56
facebook/react,e104795f635e2bb423fe9264b1cfdfff15f551e5,Sebastian Markbåge,2025-07-02T20:10:07Z,"[Fiber] Show Diff Render Props in Performance Track in DEV (#33658)  <img width=""634"" alt=""Screenshot 2025-06-27 at 1 13 20 PM"" src=""https://github.com/user-attachments/assets/dc8c488b-4a23-453f-918f-36b245364934"" />  We have to be careful with performance in DEV. It can slow down DX since these are ran whether you're currently running a performance trace or not. It can also show up as misleading since these add time to the ""Remaining Effects"" entry.  I'm not adding all props to the entries. Instead, I'm only adding the changed props after diffing and none for initial mount. I'm trying to as much as possible pick a fast path when possible. I'm also only logging this for the ""render"" entries and not the effects. If we did something for effects, it would be more like checking with dep changed.  This could still have a negative effect on dev performance since we're now also using the slower `performance.measure` API when there's a diff.",215,63,278
facebook/react,c0d151ce7ed9ebdcbcb7ea69c31d68b03b852d37,Sebastian Markbåge,2025-07-02T20:09:26Z,"Clear width/height from Keyframes to Optimize View Transitions (#33576)  View Transitions has this annoying quirk where it adds `width` and `height` to keyframes automatically when generating keyframes even when it's not needed. This causes them to deopt from running on the compositor thread in both Chrome and Safari. @bramus has a [good article on it](https://www.bram.us/2025/02/07/view-transitions-applied-more-performant-view-transition-group-animations/).  In React we can automatically rewrite the keyframes when we're starting a View Transition to drop the `width` and `height` from the keyframes when they have the same value and the same value as the pseudo element.  To compare it against the pseudo element we first apply the new keyframes without the width/height and then read it back to see if it has changed. For gestures, we have already cancelled the previous animation so we can just read out from that.",107,1,108
facebook/react,fc41c24aa6e674319aed5bd0b25ca6fb92c268df,Sebastian Markbåge,2025-07-02T20:07:46Z,"Add ScrollTimeline Polyfill for Swipe Recognizer using a new CustomTimeline protocol (#33501)  The React API is just that we now accept this protocol as an alternative to a native `AnimationTimeline` to be passed to `startGestureTransition`. This is specifically the DOM version.  ```js interface CustomTimeline {   currentTime: number;   animate(animation: Animation): void | (() => void); } ```  Instead, of passing this to the `Animation` that we start to control the View Transition keyframes, we instead inverse the control and pass the `Animation` to this one. It lets any custom implementation drive the updates. It can do so by updating the time every frame or letting it run a time based animation (such as momentum scroll).  In this case I added a basic polyfill for `ScrollTimeline` in the example but we'll need a better one.",155,43,198
facebook/react,73aa744b7029556430f409ec3887a714940698ba,Jan Kassens,2025-07-02T14:45:37Z,Remove now dead argument from resolveClassComponentProps (#33682)  No longer used after https://github.com/facebook/react/pull/33648,3,23,26
facebook/react,602917c8cb521e6f9b8eae7070985e2a698fc0d0,Jan Kassens,2025-07-01T19:52:56Z,Cleanup disableDefaultPropsExceptForClasses flag (#33648),18,1023,1041
facebook/react,91d097b2c588a0977a7a10ed12512dc8a34e3a5b,Ruslan Lesiutin,2025-07-01T17:06:26Z,"fix: rename bottom stack frame (#33680)  `react-stack-bottom-frame` -> `react_stack_bottom_frame`.  This survives `@babel/plugin-transform-function-name`, but now frames will be displayed as `at Object.react_stack_bottom_frame (...)` in V8. Checks that were relying on exact function name match were updated to use either `.indexOf()` or `.includes()`  For backwards compatibility, both React DevTools and Flight Client will look for both options. I am not so sure about the latter and if React version is locked.",48,41,89
facebook/react,7216c0f002222cdee3075410f7432d64724640cc,Sebastian Markbåge,2025-06-30T20:15:19Z,[Flight] Don't assume _debugStack and _owner is defined for prod elements (#33675)  We generally treat these types of fields as optional on ReactDebugInfo and should on ReactElement too.  That way we can consume prod payloads from third parties.,4,4,8
facebook/react,6a3d16ca74acd28632dabccc142d42ce411a811b,Jan Kassens,2025-06-30T19:26:45Z,"Back out ""Remove Dead Code in WWW JS"" (#33673)  Original commit changeset: 65c4decb565b  This was removed by dead code removal. Adding back the TODO with commented out code.",6,0,6
facebook/react,65c4decb565b4eb1423518e76dbda7bc40a01c04,Facebook Community Bot,2025-06-30T15:24:29Z,Remove Dead Code in WWW JS  Differential Revision: D77531947  Pull Request resolved: https://github.com/facebook/react/pull/33672,0,4,4
facebook/react,1e0d12b6f273d7345e32c16cd937475ed7c512ad,Dawid Małecki,2025-06-30T14:36:49Z,Align `AttributeConfiguration` type in `ReactNativeTypes` (#33671),1,1,2
facebook/react,e9cab42ece435ac3478ec85847e352177e596ae0,Sebastian Markbåge,2025-06-30T13:21:04Z,"Special case printing Promises in Performance Track Properties (#33670)  Before: <img width=""266"" alt=""Screenshot 2025-06-30 at 8 32 23 AM"" src=""https://github.com/user-attachments/assets/98aae5e1-4b2c-49bd-9b71-040b788c36ba"" />  After: <img width=""342"" alt=""Screenshot 2025-06-30 at 8 39 17 AM"" src=""https://github.com/user-attachments/assets/cd91c4a6-f6ae-4bec-9cd9-f42f4af468fe"" />",34,0,34
facebook/react,3cfcdfb30720a5b8de0e981c8fdabec1abb61588,Sebastian Markbåge,2025-06-29T14:56:16Z,"[Flight] Resolve Deep Cycles (#33664)  Stacked on #33666.  If we ever get a future reference to a cycle and that reference gets eagerly parsed before the target has loaded then we can end up with a cycle that never gets resolved. That's because our cycle resolution only works if the cyclic future reference is created synchronously within the parsing path of the child.  I haven't been able to construct a normal scenario where this would break. So this doesn't fail any tests. However, I can construct it with debug info since those are eagerly evaluated. It's also a prerequisite if the debug data can come out of order, like if it's on a different stream.  The fix here is to make all the internal dependencies in the ""listener"" list into introspectable objects instead of closures. That way we can traverse the list of dependencies of a blocked reference to see if it ends up in a cycle and therefore skip the reference.  It would be nice to address this once and for all to be more resilient to server changes, but I'm not sure if it's worth this complexity and the extra CPU cost of tracing the dependencies. Especially if it's just for debug data.  closes #32316 fixes vercel/next.js#72104  ---------  Co-authored-by: Hendrik Liebau <mail@hendrik-liebau.de>",422,162,584
facebook/react,9c2a8dd5f87266308a8a8e55fb7f029ba530d36a,Sebastian Markbåge,2025-06-29T14:47:33Z,[Flight] Ensure we dedupe references if we later discover that it's the model root (#33666)  I noticed we weren't deduping these cases.,55,0,55
facebook/react,811e203ed42c1a496790426a687d5045c473653d,Sebastian Markbåge,2025-06-27T20:27:45Z,[Flight] Don't replay performance logs when replayConsoleLogs is false (#33656)  This is the same principle. They're both side-effects and go to the `console.*` namespace.,36,30,66
facebook/react,d92056efb3dc7f1f5579934ea46132a658d418f4,Ruslan Lesiutin,2025-06-27T15:17:08Z,React DevTools 6.1.2 -> 6.1.3 (#33657)  Full list of changes:  * devtools: emit performance entries only when profiling ([hoxyq](https://github.com/hoxyq) in [#33652](https://github.com/facebook/react/pull/33652)) * Get Server Component Function Location for Parent Stacks using Child's Owner Stack ([sebmarkbage](https://github.com/sebmarkbage) in [#33629](https://github.com/facebook/react/pull/33629)) * Added minimum indent size to Component Tree ([jsdf](https://github.com/jsdf) in [#33517](https://github.com/facebook/react/pull/33517)) * [devtools-shell] layout options for testing ([jsdf](https://github.com/jsdf) in [#33516](https://github.com/facebook/react/pull/33516)) * Remove feature flag enableRenderableContext ([kassens](https://github.com/kassens) in [#33505](https://github.com/facebook/react/pull/33505)) * refactor[devtools]: update css for settings and support css variables in shadow dom scnenario ([hoxyq](https://github.com/hoxyq) in [#33487](https://github.com/facebook/react/pull/33487)) * [mcp] Add MCP tool to print out the component tree of the currently open React App ([jorge-cab](https://github.com/jorge-cab) in [#33305](https://github.com/facebook/react/pull/33305)) * [scripts] Switch back to flow parser for prettier ([rickhanlonii](https://github.com/rickhanlonii) in [#33414](https://github.com/facebook/react/pull/33414)) * upgrade json5 ([rickhanlonii](https://github.com/rickhanlonii) in [#33358](https://github.com/facebook/react/pull/33358)) * Get source location from structured callsites in prepareStackTrace ([sebmarkbage](https://github.com/sebmarkbage) in [#33143](https://github.com/facebook/react/pull/33143)) * Clean up enableSiblingPrerendering flag ([jackpope](https://github.com/jackpope) in [#32319](https://github.com/facebook/react/pull/32319)),21,10,31
facebook/react,58ac15cdc953a21ac1b352b6300abc3da87fa3d6,Ruslan Lesiutin,2025-06-27T14:32:08Z,devtools: emit performance entries only when profiling (#33652)  ## Summary  This floods Timings track in dev mode and also hurts performance in dev.  Making sure we are buffering Performance entries (all of them are marks) only when profiling in RDT. This should be removed once we roll out Perf tracks.,119,147,266
facebook/react,bfc8801e0f0bfacb46bc71244e8244736bd995f4,Sebastian Markbåge,2025-06-27T13:45:11Z,[Flight] Write Debug Info to Separate Priority Queue (#33654)  This writes all debug info to a separate priority queue. In the future I'll put this on a different channel.  Ideally I think we'd put it in the bottom of the stream but because it actually blocks the elements from resolving anyway it ends up being better to put them ahead. At least for now.  When we have two separate channels it's not possible to rely on the order for consistency Even then we might write to that queue first for this reason. We can't rely on it though. Which will show up like things turning into Lazy instead of Element similar to how outlining can.,354,135,489
facebook/react,d2a288febf61a1755b78ce98b3cb17dd412b81e3,Sebastian Markbåge,2025-06-27T12:45:56Z,"Include Component Props in Performance Track (#33655)  Similar to how we can include a Promise resolved value we can include Component Props.  For now I left out props for Client Components for perf unless they error. I'll try it for Client Components in general in a separate PR.  <img width=""730"" alt=""Screenshot 2025-06-26 at 5 54 29 PM"" src=""https://github.com/user-attachments/assets/f0c86911-2899-4b5f-b45f-5326bdbc630f"" /> <img width=""762"" alt=""Screenshot 2025-06-26 at 5 54 12 PM"" src=""https://github.com/user-attachments/assets/97540d19-5950-4346-99e6-066af086040e"" />",245,139,384
facebook/react,4db4b21c63ebc4edc508c5f7674f9df50d8f9744,Dhruv,2025-06-26T15:34:45Z,"Fix typo ""Complier"" to ""Compiler"" and remove duplicate issue reference (#33653)  <!--   Thanks for submitting a pull request! We appreciate you spending the time to work on these changes. Please provide enough information so that others can review your pull request. The three fields below are mandatory.  Before submitting a pull request, please make sure the following is done:  1. Fork [the repository](https://github.com/facebook/react) and create your branch from `main`.   2. Run `yarn` in the repository root. 3. If you've fixed a bug or added code that should be tested, add tests! 4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch TestName` is helpful in development. 5. Run `yarn test --prod` to test in the production environment. It supports the same options as `yarn test`. 6. If you need a debugger, run `yarn test --debug --watch TestName`, open `chrome://inspect`, and press ""Inspect"". 7. Format your code with [prettier](https://github.com/prettier/prettier) (`yarn prettier`). 8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only check changed files.   9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).   10. If you haven't already, complete the CLA.  Learn more about contributing: https://reactjs.org/docs/how-to-contribute.html -->  ## Summary Fixed a typo in the changelog.md file: corrected ""Complier"" to ""Compiler"" and removed a duplicate issue reference for improved clarity. <!-- Explain the **motivation** for making this change. What existing problem does the pull request solve? -->  ## How did you test this change? Manually reviewed the changelog text to ensure correctness. No code changes were made. <!-- Demonstrate the code is solid. Example: The exact commands you ran and their output, screenshots / videos if the pull request changes the user interface. How exactly did you verify that your PR solves the issue you wanted to solve?   If you leave this empty, your PR will very likely be closed. -->",2,2,4
facebook/react,31d91651e042e4939021f21a3d8799c13684a84b,Sebastian Markbåge,2025-06-26T01:18:25Z,[Fizz] Rename ReactFizzContext to ReactFizzLegacyContext (#33649)  #33622 forgot these.,2,2,4
facebook/react,9406162bc95f1db78169a7f5e11bc56d324b2071,Sebastian Markbåge,2025-06-25T21:28:59Z,"[Flight] Emit start time before an await if one wasn't emitted already (#33646)  There's a special case where if we create a new task, e.g. to serialize a promise like `<div>{promise}</div>` then that row doesn't have any start time emitted but it has a `task.time` inherited. We mostly don't need this because every other operation emits its own start time. E.g. when we started rendering a Server Component or the real start time of a real `await`.  For these implied awaits we don't have a start time. Ideally it would probably be when we started the serialization, like when we called `.then()` but we can't just emit that eagerly and we can't just advance the `task.time` because that time represents the last render or previous await and we use that to cut off awaits. However for this case we don't want to cut off any inner awaits inside the node we're serializing if they happened before the `.then()`.  Therefore, I just use the time of the previous operation - which is likely either the resolution of a previous promise that blocked the `<div>` like the promise of the Server Component that rendered it, or just the start of the Server Component if it was sync.",8,0,8
facebook/react,9b2a545b32ef19c6b67812d2c3444a709406a58b,Hendrik Liebau,2025-06-25T20:34:35Z,"[Flight] Add tests for component and owner stacks of halted components (#33644)  This PR adds tests for the Node.js and Edge builds to verify that component stacks and owner stacks of halted components appear as expected, now that recent enhancements for those have been implemented (the latest one being #33634).  ---------  Co-authored-by: Sebastian ""Sebbie"" Silbermann <silbermann.sebastian@gmail.com>",304,0,304
facebook/react,bb6c9d521e7f44eb9a9754a14cde62c8e6439e5e,Sebastian Markbåge,2025-06-25T20:28:54Z,"[Flight] Log aborted await and component renders (#33641)  <img width=""926"" alt=""Screenshot 2025-06-25 at 1 02 14 PM"" src=""https://github.com/user-attachments/assets/1877d13d-5259-4cc4-8f48-12981e3073fe"" />  The I/O entry doesn't show as aborted in the Server Request track because technically it wasn't. The end time is just made up. It's still going. It's not aborted until the abort signal propagates and if we do get that signal wired up before it emits, it instead would show up as rejected.  ---------  Co-authored-by: Hendrik Liebau <mail@hendrik-liebau.de>",150,9,159
facebook/react,123ff13b193cd361a61b99056dd08f2decd7f55d,Joseph Savona,2025-06-25T18:10:38Z,"[compiler] Consolidate HIRFunction return information (#33640)  We now have `HIRFunction.returns: Place` as well as `returnType: Type`. I want to add additional return information, so as a first step i'm consolidating everything under an object at `HIRFunction.returns: {place: Place}`. We use the type of this place as the return type. Next step is to add more properties to this object to represent things like the return kind.  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33640). * #33643 * #33642 * __->__ #33640 * #33625 * #33624",16,20,36
facebook/react,e130c08b06470b5fc4ec8095310d19e782924427,Joseph Savona,2025-06-25T18:10:26Z,"[compiler] Avoid empty switch cases (#33625)  Small cosmetic win, found this when i was looking at some code internally with lots of cases that all share the same logic. Previously, all the but last one would have an empty block.  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33625). * #33643 * #33642 * #33640 * __->__ #33625 * #33624",11,21,32
facebook/react,9894c488e0d9a4d9759d80ba8666d4d094b894e9,Joseph Savona,2025-06-25T18:10:09Z,"[compiler] Fix bug with reassigning function param in destructuring (#33624)  Closes #33577, a bug with ExtractScopeDeclarationsFromDestructuring and codegen when a function param is reassigned.  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33624). * #33643 * #33642 * #33640 * #33625 * __->__ #33624",83,5,88
facebook/react,cee7939b0017ff58230e19663c22393bfd9025ef,Sebastian Markbåge,2025-06-25T15:14:49Z,"[Fizz] Push a stalled await from debug info to the ownerStack/debugTask (#33634)  If an aborted task is not rendering, then this is an async abort. Conceptually it's as if the abort happened inside the async gap. The abort reason's stack frame won't have that on the stack so instead we use the owner stack and debug task of any halted async debug info.  One thing that's a bit awkward is that if you do have a sync abort and you use that error as the ""reason"" then that thing still has a sync stack in a different component. In another approach I was exploring having different error objects for each component but I don't think that's worth it.",113,17,130
facebook/react,b42341ddc757129db062298f9fe3ad041c580d2a,Sebastian Markbåge,2025-06-25T13:41:21Z,"[Flight] Use cacheController instead of abortListeners for Streams (#33633)  Now that we have `cacheSignal()` we can just use that instead of the `abortListeners` concept which was really just the same thing for cancelling the streams (ReadableStream, Blob, AsyncIterable).",59,93,152
facebook/react,7a3ffef70339c10f8d65a27b88cd73bfbe13eb8a,Pieter De Baets,2025-06-25T09:23:36Z,"[react-native] Consume ReactNativeAttributePayloadFabric from ReactNativePrivateInterface (#33616)  ## Summary  ReactNativeAttributePayloadFabric was synced to react-native in https://github.com/facebook/react-native/commit/0e42d33cbcfadcf5d787108da785d56a83d07a9f. We should now consume these methods from the ReactNativePrivateInterface.  Moving these methods to the React Native repo gives us more flexibility to experiment with new techniques for bridging and diffing props payloads.  I did have to leave some stub implementations for existing unit tests, but moved all detailed tests to the React Native repo.  ## How did you test this change?  * `yarn prettier` * `yarn test ReactFabric-test`",82,1014,1096
facebook/react,e67b4fe22e0c3c267303ee6737aec1db48055022,Sebastian Markbåge,2025-06-24T20:36:21Z,"[Flight] Emit Partial Debug Info if we have any at the point of aborting a render (#33632)  When we abort a render we don't really have much information about the task that was aborted. Because before a Promise resolves there's no indication about would have resolved it. In particular we don't know which I/O would've ultimately called resolve().  However, we can at least emit any information we do have at the point where we emit it. At the least the stack of the top most Promise.  Currently we synchronously flush at the end of an `abort()` but we should ideally schedule the flush in a macrotask and emit this debug information right before that. That way we would give an opportunity for any `cacheSignal()` abort to trigger rejections all the way up and those rejections informs the awaited stack.  ---------  Co-authored-by: Hendrik Liebau <mail@hendrik-liebau.de>",79,2,81
facebook/react,4a523489b7dc64cd397f619e50223edda1b9a321,Sebastian Markbåge,2025-06-24T20:35:28Z,"Get Server Component Function Location for Parent Stacks using Child's Owner Stack (#33629)  This is using the same trick as #30798 but for runtime code too. It's essential zero cost.  This lets us include a source location for parent stacks of Server Components when it has an owned child's location. Either from JSX or I/O.  Ironically, a Component that throws an error will likely itself not get the stack because it won't have any JSX rendered yet.",47,9,56
facebook/react,94cf60bede7cd6685e07a4374d1e3aa90445130b,Joseph Savona,2025-06-24T17:01:58Z,"[compiler] New inference repros/fixes (#33584)  Substantially improves the last major known issue with the new inference model's implementation: inferring effects of function expressions. I knowingly used a really simple (dumb) approach in InferFunctionExpressionAliasingEffects but it worked surprisingly well on a ton of code. However, investigating during the sync I saw that we the algorithm was literally running out of memory, or crashing from arrays that exceeded the maximum capacity. We were accumluating data flow in a way that could lead to lists of data flow captures compounding on themselves and growing very large very quickly. Plus, we were incorrectly recording some data flow, leading to cases where we reported false positive ""can't mutate frozen value"" for example.  So I went back to the drawing board. InferMutationAliasingRanges already builds up a data flow graph which it uses to figure out what values would be affected by mutations of other values, and update mutable ranges. Well, the key question that we really want to answer for inferring a function expression's aliasing effects is which values alias/capture where. Per the docs I wrote up, we only have to record such aliasing _if they are observable via mutations_. So, lightbulb: simulate mutations of the params, free variables, and return of the function expression and see which params/free-vars would be affected! That's what we do now, giving us precise information about which such values alias/capture where. When the ""into"" is a param/context-var we use Capture, iwhen the destination is the return we use Alias to be conservative.  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33584). * #33626 * #33625 * #33624 * __->__ #33584",746,265,1011
facebook/react,bbc13fa17be8eebef3e6ee47f48c76c0c44e2f36,Sebastian Markbåge,2025-06-24T15:16:09Z,"[Flight] Add Debug Channel option for stateful connection to the backend in DEV (#33627)  This adds plumbing for opening a stream from the Flight Client to the Flight Server so it can ask for more data on-demand. In this mode, the Flight Server keeps the connection open as long as the client is still alive and there's more objects to load. It retains any depth limited objects so that they can be asked for later. In this first PR it just releases the object when it's discovered on the server and doesn't actually lazy load it yet. That's coming in a follow up.  This strategy is built on the model that each request has its own channel for this. Instead of some global registry. That ensures that referential identity is preserved within a Request and the Request can refer to previously written objects by reference.  The fixture implements a WebSocket per request but it doesn't have to be done that way. It can be multiplexed through an existing WebSocket for example. The current protocol is just a Readable(Stream) on the server and WritableStream on the client. It could even be sent through a HTTP request body if browsers implemented full duplex (which they don't).  This PR only implements the direction of messages from Client to Server. However, I also plan on adding Debug Channel in the other direction to allow debug info (optionally) be sent from Server to Client through this channel instead of through the main RSC request. So the `debugChannel` option will be able to take writable or readable or both.  ---------  Co-authored-by: Hendrik Liebau <mail@hendrik-liebau.de>",1385,68,1453
facebook/react,12eaef7ef5fbf6c9d7ec6e16a04bc207a1a68b91,Ricky,2025-06-24T00:07:04Z,[refactor] remove unused fiberstack functions (#33623),1,32,33
facebook/react,c80c69fa965a517c2978b0cb39bdb49c0e1cb5c8,Sebastian Markbåge,2025-06-23T22:37:52Z,"[Flight] Remove back pointers to the Response from the Chunks (#33620)  This frees some memory that will be even more important in a follow up.  Currently, all `ReactPromise` instances hold onto their original `Response`. The `Response` holds onto all objects that were in that response since they're needed in case the parsed content ends up referring to an existing object. If everything you retain are plain objects then that's fine and the `Response` gets GC:ed, but if you're retaining a `Promise` itself then it holds onto the whole `Response`.  The only thing that needs this reference at all is a `ResolvedModelChunk` since it will lazily initialize e.g. by calling `.then` on itself and so we need to know where to find any sibling chunks it may refer to. However, we can just store the `Response` on the `reason` field for this particular state.  That way when all lazy values are touched and initialized the `Response` is freed. We also free up some memory by getting rid of the extra field.",34,39,73
facebook/react,aab72cb1cbfc30f07af7b949fb9dc8d7497d73ca,Jan Kassens,2025-06-23T21:21:18Z,"rename ReactFiberContext to ReactFiberLegacyContext (#33622)  It wasn't immediately obvious to me, that all the exports here are related to legacy context, so renaming for clarity.  Modern context lives in `ReactFiberNewContext` which we could probably also raname in a separate step to just Context.",8,8,16
facebook/react,fa3feba6720c96ca10fb42d5f53a9b4fa9aa6ccd,"Sebastian ""Sebbie"" Silbermann",2025-06-23T15:47:07Z,"Fix prelease workflows for `dry: false` (#33582)  ## Summary  Follow-up to https://github.com/facebook/react/pull/33525  Fixes `Unsupported tag: ""false""` (https://github.com/facebook/react/actions/runs/15773778995/job/44463562733#step:13:12) which also affects nightly releases.  ## How did you test this change?  - [x] Run successful, manual prerelease from this branch: https://github.com/facebook/react/actions/runs/15774083406",5,5,10
facebook/react,2a911f27dd99c46778c27ba004f9d8fe898efd21,Sebastian Markbåge,2025-06-23T14:12:45Z,"[Flight] Send the awaited Promise to the client as additional debug information (#33592)  Stacked on #33588, #33589 and #33590.  This lets us automatically show the resolved value in the UI.  <img width=""863"" alt=""Screenshot 2025-06-22 at 12 54 41 AM"" src=""https://github.com/user-attachments/assets/a66d1d5e-0513-4767-910c-5c7169fc2df4"" />  We can also show rejected I/O that may or may not have been handled with the error message.  <img width=""838"" alt=""Screenshot 2025-06-22 at 12 55 06 AM"" src=""https://github.com/user-attachments/assets/e0a8b6ae-08ba-46d8-8cc5-efb60956a1d1"" />  To get this working we need to keep the Promise around for longer so that we can access it once we want to emit an async sequence. I do this by storing the WeakRefs but to ensure that the Promise doesn't get garbage collected, I keep a WeakMap of Promise to the Promise that it depended on. This lets the VM still clean up any Promise chains that have leaves that are cleaned up. So this makes Promises live until the last Promise downstream is done. At that point we can go back up the chain to read the values out of them.  Additionally, to get the best possible value we don't want to get a Promise that's used by internals of a third-party function. We want the value that the first party gets to observe. To do this I had to change the logic for which ""await"" to use, to be the one that is the first await that happened in user space. It's not enough that the await has any first party at all on the stack - it has to be the very first frame. This is a little sketchy because it relies on the `.then()` call or `await` call not having any third party wrappers. But it gives the best object since it hides all the internals. For example when you call `fetch()` we now log that actual `Response` object.",791,296,1087
facebook/react,18ee505e7791f2bb55f0e520667c51588df7ba48,Sebastian Markbåge,2025-06-22T22:00:08Z,"[Flight] Support classes in renderDebugModel (#33590)  This adds better support for serializing class instances as Debug values.  It adds a new marker on the object `{ """": ""$P..."", ... }` which indicates which constructor's prototype to use for this object's prototype. It doesn't encode arbitrary prototypes and it doesn't encode any of the properties on the prototype. It might get some of the properties from the prototype by virtue of `toString` on a `class` constructor will include the whole class's body.  This will ensure that the instance gets the right name in logs.  Additionally, this now also invokes getters if they're enumerable on the prototype. This lets us reify values that can only be read from native classes.  ---------  Co-authored-by: Hendrik Liebau <mail@hendrik-liebau.de>",141,4,145
facebook/react,1d1b26c701893f4821ebdc6547bcd1efc392f679,Sebastian Markbåge,2025-06-22T21:51:31Z,"[Flight] Serialize already resolved Promises as debug models (#33588)  We already support serializing the values of instrumented Promises as debug values such as in console logs. However, we don't support plain native promises.  This waits a microtask to see if we can read the value within a microtask and if so emit it. This is so that we can still close the connection.  Otherwise, we emit a ""halted"" row into its row id which replaces the old ""Infinite Promise"" reference.  We could potentially wait until the end of the render before cancelling so that if it resolves before we exit we can still include its value but that would require a bit more work. Ideally we'd have a way to get these lazily later anyway.",204,47,251
facebook/react,fe3f0ec0374b7323bf259e4154eb4ee739caac7b,Sebastian Markbåge,2025-06-22T14:40:56Z,[Flight] Don't use object property initializer for async iterable (#33591)  It turns out this was being compiled to a `_defineProperty` helper by Babel or Closure. We're supposed to have it error the build when we use features like this that might get compiled.  We should stick to simple ES5 features.,25,23,48
facebook/react,d70ee32b8867f6cf99b1787f8adb4f3705756805,Sebastian Markbåge,2025-06-22T14:40:33Z,"[Flight] Eagerly parse stack traces in DebugNode (#33589)  There's a memory leak in DebugNode where the `Error` objects that we instantiate retains their callstacks which can have Promises on them. In fact, it's very likely since the current callsite has the ""resource"" on it which is the Promise itself. If those Promises are retained then their `destroy` async hook is never fired which doesn't clean up our map which can contains the `Error` object. Creating a cycle that can't be cleaned up.  This fix is just eagerly reifying and parsing the stacks.  I totally expect this to be crazy slow since there's so many Promises that we end up not needing to visit otherwise. We'll need to optimize it somehow. Perhaps by being smarter about which ones we might need stacks for. However, at least it doesn't leak indefinitely.",18,19,37
facebook/react,6c7b1a1d9898025bb087a3b97d875091e4f67cf3,Sebastian Markbåge,2025-06-21T14:36:07Z,Rename serializeConsoleMap/Set to serializeDebugMap/Set (#33587)  Follow up to #33583. I forgot to rename these too.,4,4,8
facebook/react,ed077194b5b76df6f8fdbf805e1b895e2deb5a07,Sebastian Markbåge,2025-06-20T17:36:39Z,"[Flight] Dedupe objects serialized as Debug Models in a separate set (#33583)  Stacked on #33539.  Stores dedupes of `renderConsoleValue` in a separate set. This allows us to dedupe objects safely since we can't write objects using this algorithm if they might also be referenced by the ""real"" serialization.  Also renamed it to `renderDebugModel` since it's not just for console anymore.",151,113,264
facebook/react,643257ca52c92d74ef7b7c7b474e5cae9e5451e4,Devon Govett,2025-06-20T17:36:07Z,"[Flight] Serialize functions by reference (#33539)  On pages that have a high number of server components (e.g. common when doing syntax highlighting), the debug outlining can produce extremely large RSC payloads. For example a documentation page I was working on had a 13.8 MB payload. I noticed that a majority of this was the source code for the same function components repeated over and over again (over 4000 times) within `$E()` eval commands.  This PR deduplicates the same functions by serializing by reference, similar to what is already done for objects. Doing this reduced the payload size of my page from 13.8 MB to 4.6 MB, and resulted in only 31 evals instead of over 4000. As a result it reduced development page load and hydration time from 4 seconds to 1.5 seconds. It also means the deserialized functions will have reference equality just as they did on the server.",20,2,22
facebook/react,06e89951be5b4b23ca343d02721521fe392e94c5,"Sebastian ""Sebbie"" Silbermann",2025-06-20T12:21:57Z,[Fizz] Ignore error if content node is gone before reveal (#33531),11,7,18
facebook/react,79d9aed7edb52e89b3ef9ba3d6b480b04180b664,Sebastian Markbåge,2025-06-20T07:26:26Z,[Fizz] Clean up the replay nodes if we're already rendered past an element  (#33581),7,0,7
facebook/react,c8822e926b79205fd2e828c81e031bd0afc0effc,"Sebastian ""Sebbie"" Silbermann",2025-06-20T07:11:27Z,Make it clearer what runtime release failed (#33579),1,1,2
facebook/react,a947eba4f2c8741d2c61a3b33fd79cf13bf9f39d,"Sebastian ""Sebbie"" Silbermann",2025-06-19T21:40:59Z,Fix CI (#33578),6,4,10
facebook/react,374dfe8edf8beef62e5bb312f99c600a232f353f,Ruslan Lesiutin,2025-06-19T08:47:23Z,"build: make enableComponentPerformanceTrack dynamic for native-fb (#33560)  ## Summary  Make this flag dynamic, so it can be controlled internally.  ## How did you test this change?  Build, observe that `console.timeStamp` is only present in FB artifacts and `enableComponentPerformanceTrack` is referenced.",3,1,4
facebook/react,2bee34867d30083ce01232baccb72b6fa696456b,Joseph Savona,2025-06-18T23:00:55Z,[compiler] Cleanup debugging code (#33571)  Removes unnecessary debugging code in the new inference passes now that they've stabilized more.  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33571). * __->__ #33571 * #33558 * #33547,17,158,175
facebook/react,d37faa041bce86c1cbb05fdbc839440c9d9de9cf,Joseph Savona,2025-06-18T23:00:45Z,"[compiler] Preserve Create effects, guarantee effects initialize once (#33558)  Ensures that effects are well-formed with respect to the rules: * For a given instruction, each place is only initialized once (w one of Create, CreateFrom, Assign) * Ensures that Alias targets are already initialized within the same instruction (should have a Create before them) * Preserves Create and similar instructions * Avoids duplicate instructions when inferring effects of function expressions  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33558). * #33571 * __->__ #33558 * #33547",88,28,116
facebook/react,3a2ff8b51b5ab54c22f55a5f826c53419f718887,Joseph Savona,2025-06-18T23:00:36Z,"[compiler] Fix <ValidateMemoization> (#33547)  By accident we were only ever checking the compiled output, but the intention was in general to be able to compare memoization with/without forget.  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33547). * #33571 * #33558 * __->__ #33547",141,74,215
facebook/react,cc3806377a43f0bd339d54ceaf2e1e16b0b113bf,Joseph Savona,2025-06-18T22:56:27Z,"[compiler] Tests for different orders of createfrom/capture w/wo function expressions (#33543)  Adds some typed helpers to represent aliasing, assign, capture, createfrom, and mutate effects along with representative runtime behavior, and then adds tests to demonstrate that we model capture->createfrom and createfrom->capture correctly.  There is one case (createfrom->capture in a lambda) where we infer a less precise effect, but in the more conservative direction (we include more code/deps than necesssary rather than fewer).  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33543). * #33571 * #33558 * #33547 * __->__ #33543",1289,7,1296
facebook/react,4f543f326cdf99d1bb2accd1c4f4e5bfffffeb4b,Joseph Savona,2025-06-18T22:48:01Z,[compiler] Docs describing new inference model (#33533)  Start of docs describing the effects and the inference rules.  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33533). * #33571 * #33558 * #33547 * #33543 * __->__ #33533 * #33532 * #33530,524,0,524
facebook/react,7ceb10035faf79eb6a645938ab15099126714381,Joseph Savona,2025-06-18T22:47:52Z,[compiler] Rename InferFunctionExprAliasingEffectsSignature (#33532)  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33532). * #33571 * #33558 * #33547 * #33543 * #33533 * __->__ #33532 * #33530,4,4,8
facebook/react,4335f699870920932c8f30b6ad52173c3d819d16,Joseph Savona,2025-06-18T22:47:43Z,"[compiler] More readable alias signature declarations (#33530)  Now that we have support for defining aliasing signatures in moduleTypeProvider, which uses string names for receiver/args/returns/etc, we can reuse that same form for builtin declarations. The declarations are written in the unparsed form and than parsed/validated when registered (in the addFunction/addHook call).  This also required flushing out configs/schemas for more effect types.  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33530). * #33571 * #33558 * #33547 * #33543 * #33533 * #33532 * __->__ #33530",327,166,493
facebook/react,34179fe3449e141e980bbeaa8fc0a61b156113bb,Joseph Savona,2025-06-18T22:43:48Z,[compiler] moduleTypeProvider support for aliasing signatures (#33526)  This allows us to type things like `nullthrows()` or `identity()` functions where the return type is polymorphic on the input.  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33526). * #33571 * #33558 * #33547 * #33543 * #33533 * #33532 * #33530 * __->__ #33526 * #33522 * #33518,515,2,517
facebook/react,0e7cdebb32817de0e0bbee3b362f0959e36c959c,Joseph Savona,2025-06-18T22:43:33Z,"[compiler] Repro for case of lost precision in new inference (#33522)  In comparing compilation output of the old/new inference models I found this case (heavily distilled into a fixture). Roughly speaking the scenario is:  * Create a mutable object `x` * Extract part of that object and pass it to a hook/jsx so that _part_ becomes frozen * Mutate `x`, even indirectly.  In the old model we can still independently memoize the value from the middle step, since we assume that part of the larger value is not changing. In the new model, the mutation from the later step effectively overrides the freeze effect in step 2, and considers the value to have changed later anyway.  We've already rolled out and vetted the previous behavior, confirming that the heuristic of ""that part of the mutable object is fozen now"" is generally safe. I'll fix in a follow-up.  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33522). * #33571 * #33558 * #33547 * #33543 * #33533 * #33532 * #33530 * #33526 * __->__ #33522 * #33518",68,0,68
facebook/react,81d81151169be4b1b0ad8bd6439e94cfc982bb5a,Joseph Savona,2025-06-18T22:43:23Z,"[compiler] Fix infinite loop due to uncached applied signatures (#33518)  When we apply new aliasing signatures we can generate new temporaries, which causes the abstract memory model to not converge. The fix is to make sure we cache the applications of these signatures.  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33518). * #33571 * #33558 * #33547 * #33543 * #33533 * #33532 * #33530 * #33526 * #33522 * __->__ #33518",237,75,312
facebook/react,8f4ce72f0bfe02e51e9a7c704dc33122d909f292,Joseph Savona,2025-06-18T22:24:41Z,"[commit] Improve error for hoisting violations (#33514)  The previous error for hoisting violations pointed only to the variable declaration, but didn't show where the value was accessed before that declaration. We now track where each hoisted variable is first accessed and report two errors, one for the reference and one for the declaration. When we improve our diagnostic infra to support reporting errors at multiple locations we can merge these into a single conceptual error.  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33514). * #33571 * #33558 * #33547 * #33543 * #33533 * #33532 * #33530 * #33526 * #33522 * #33518 * __->__ #33514 * #33573",86,42,128
facebook/react,7ce2a63acc199a4f8829625470ea56a347632340,Joseph Savona,2025-06-18T22:24:30Z,[compiler] update fixtures (#33573)  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33573). * #33571 * #33558 * #33547 * #33543 * #33533 * #33532 * #33530 * #33526 * #33522 * #33518 * #33514 * __->__ #33573,140,176,316
facebook/react,b067c6fe7962ce2c8ddca6deeadcb21afe2538f8,Joseph Savona,2025-06-18T20:04:53Z,"[compiler] Improve error message for mutating hook args/return (#33513)  The previous error message was generic, because the old style function signature didn't support a way to specify a reason alongside a freeze effect. This meant we could only say why a value was frozen for instructions, but not hooks which use function signatures. By defining a new aliasing signature for custom hooks we can specify a reason and provide a better error message.  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33513). * #33571 * #33558 * #33547 * #33543 * #33533 * #33532 * #33530 * #33526 * #33522 * #33518 * #33514 * __->__ #33513",71,26,97
facebook/react,e081cb344652dc3003d9194cca618292a889ff2a,Joseph Savona,2025-06-18T20:02:43Z,"[compiler] FunctionExpression context locations point to first reference (#33512)  This has always been awkward: `FunctionExpression.context` places have locations set to the declaration of the identifier, whereas other references have locations pointing to the reference itself. Here, we update context operands to have their location point to the first reference of that variable within the function.  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33512). * #33571 * #33558 * #33547 * #33543 * #33533 * #33532 * #33530 * #33526 * #33522 * #33518 * #33514 * #33513 * __->__ #33512 * #33504 * #33500 * #33497 * #33496",35,21,56
facebook/react,7b67dc92b0339062ce8b6a1d64a458d7c8f04561,Joseph Savona,2025-06-18T20:02:32Z,"[commit] Better error message for invalid hoisting (#33504)  We're already tracking which variables are hoisted context variables, so if we see a mutation of a frozen value we can emit a custom error message to help users identify the problem.  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33504). * #33571 * #33558 * #33547 * #33543 * #33533 * #33532 * #33530 * #33526 * #33522 * #33518 * #33514 * #33513 * #33512 * __->__ #33504 * #33500 * #33497 * #33496",97,11,108
facebook/react,7c28c154651f54a63a6823e4dc54faa218c05a89,Joseph Savona,2025-06-18T20:02:23Z,"[compiler] Fix AnalyzeFunctions to fully reset context identifiers (#33500)  AnalyzeFunctions had logic to reset the mutable ranges of context variables after visiting inner function expressions. However, there was a bug in that logic: InferReactiveScopeVariables makes all the identifiers in a scope point to the same mutable range instance. That meant that it was possible for a later function expression to indirectly cause an earlier function expressions' context variables to get a non-zero mutable range.  The fix is to not just reset start/end of context var ranges, but assign a new range instance. Thanks for the help on debugging, @mofeiz!  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33500). * #33571 * #33558 * #33547 * #33543 * #33533 * #33532 * #33530 * #33526 * #33522 * #33518 * #33514 * #33513 * #33512 * #33504 * __->__ #33500 * #33497 * #33496",115,2,117
facebook/react,90ccbd71c158a8aeb1bf3ec704011ddd58842b71,Joseph Savona,2025-06-18T20:02:12Z,[compiler] Enable new inference by default (#33497)  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33497). * #33571 * #33558 * #33547 * #33543 * #33533 * #33532 * #33530 * #33526 * #33522 * #33518 * #33514 * #33513 * #33512 * #33504 * #33500 * __->__ #33497 * #33496,277,203,480
facebook/react,0cf6d0c929e14d4a3c5bcc11a7347b4cad250e7f,Joseph Savona,2025-06-18T20:01:56Z,[compiler] Update fixtures for new inference (#33496)  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33496). * #33571 * #33558 * #33547 * #33543 * #33533 * #33532 * #33530 * #33526 * #33522 * #33518 * #33514 * #33513 * #33512 * #33504 * #33500 * #33497 * __->__ #33496,389,280,669
facebook/react,df080d228bdf5260067235c64daaa57ec3cfac23,Joseph Savona,2025-06-18T19:58:16Z,[compiler] Copy fixtures affected by new inference (#33495)  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33495). * #33571 * #33558 * #33547 * #33543 * #33533 * #33532 * #33530 * #33526 * #33522 * #33518 * #33514 * #33513 * #33512 * #33504 * #33500 * #33497 * #33496 * __->__ #33495 * #33494 * #33572,1912,0,1912
facebook/react,66cfe048d3ab02afd3eeba9e8d7710acb3a4ab38,Joseph Savona,2025-06-18T19:58:06Z,"[compiler] New mutability/aliasing model (#33494)  Squashed, review-friendly version of the stack from https://github.com/facebook/react/pull/33488.  This is new version of our mutability and inference model, designed to replace the core algorithm for determining the sets of instructions involved in constructing a given value or set of values. The new model replaces InferReferenceEffects, InferMutableRanges (and all of its subcomponents), and parts of AnalyzeFunctions. The new model does not use per-Place effect values, but in order to make this drop-in the end _result_ of the inference adds these per-Place effects.  I'll write up a larger document on the model, first i'm doing some housekeeping to rebase the PR.  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33494). * #33571 * #33558 * #33547 * #33543 * #33533 * #33532 * #33530 * #33526 * #33522 * #33518 * #33514 * #33513 * #33512 * #33504 * #33500 * #33497 * #33496 * #33495 * __->__ #33494 * #33572",7247,343,7590
facebook/react,ae962653d63ca88b6727d6f585026f2bbfa313a1,Joseph Savona,2025-06-18T19:57:54Z,[compiler] Remove unnecessary fixture (#33572)  This is covered by iife-inline-ternary  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33572). * #33571 * #33558 * #33547 * #33543 * #33533 * #33532 * #33530 * #33526 * #33522 * #33518 * #33514 * #33513 * #33512 * #33504 * #33500 * #33497 * #33496 * #33495 * #33494 * __->__ #33572,0,41,41
facebook/react,e1dc03492eedaec517e14a6e32b8fda571d00767,Sebastian Markbåge,2025-06-17T21:04:40Z,"Expose cacheSignal() alongside cache() (#33557)  This was really meant to be there from the beginning. A `cache()`:ed entry has a life time. On the server this ends when the render finishes. On the client this ends when the cache of that scope gets refreshed.  When a cache is no longer needed, it should be possible to abort any outstanding network requests or other resources. That's what `cacheSignal()` gives you. It returns an `AbortSignal` which aborts when the cache lifetime is done based on the same execution scope as a `cache()`ed function - i.e. `AsyncLocalStorage` on the server or the render scope on the client.  ```js import {cacheSignal} from 'react'; async function Component() {   await fetch(url, { signal: cacheSignal() }); } ```  For `fetch` in particular, a patch should really just do this automatically for you. But it's useful for other resources like database connections.  Another reason it's useful to have a `cacheSignal()` is to ignore any errors that might have triggered from the act of being aborted. This is just a general useful JavaScript pattern if you have access to a signal:  ```js async function getData(id, signal) {   try {      await queryDatabase(id, { signal });   } catch (x) {      if (!signal.aborted) {        logError(x); // only log if it's a real error and not due to cancellation      }      return null;   } } ```  This just gets you a convenient way to get to it without drilling through so a more idiomatic code in React might look something like.  ```js import {cacheSignal} from ""react"";  async function getData(id) {   try {      await queryDatabase(id);   } catch (x) {      if (!cacheSignal()?.aborted) {        logError(x);      }      return null;   } } ```  If it's called outside of a React render, we normally treat any cached functions as uncached. They're not an error call. They can still load data. It's just not cached. This is not like an aborted signal because then you couldn't issue any requests. It's also not like an infinite abort signal because it's not actually cached forever. Therefore, `cacheSignal()` returns `null` when called outside of a React render scope.  Notably the `signal` option passed to `renderToReadableStream` in both SSR (Fizz) and RSC (Flight Server) is not the same instance that comes out of `cacheSignal()`. If you abort the `signal` passed in, then the `cacheSignal()` is also aborted with the same reason. However, the `cacheSignal()` can also get aborted if the render completes successfully or fatally errors during render - allowing any outstanding work that wasn't used to clean up. In the future we might also expand on this to give different [`TaskSignal`](https://developer.mozilla.org/en-US/docs/Web/API/TaskSignal) to different scopes to pass different render or network priorities.  On the client version of `""react""` this exposes a noop (both for Fiber/Fizz) due to `disableClientCache` flag but it's exposed so that you can write shared code.",183,11,194
facebook/react,90bee819028bfecb724df298da798607b6a76abf,Jordan Brown,2025-06-17T01:53:50Z,"[compiler] Do not inline IIFEs in value blocks (#33548)  As discussed in chat, this is a simple fix to stop introducing labels inside expressions.  The useMemo-with-optional test was added in https://github.com/facebook/react/commit/d70b2c2c4e85c2a7061214c15a8ff13167d10422 and crashes for the same reason- an unexpected label as a value block terminal.  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33548). * __->__ #33548 * #33546",203,122,325
facebook/react,75e78d243f749d009fa1c5c09c3464301b992718,Jordan Brown,2025-06-17T01:53:27Z,[compiler] Add repro for IIFE in ternary causing a bailout (#33546)  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33546). * #33548 * __->__ #33546,41,0,41
facebook/react,5d24c64cc9c019fc644c4c6f0da640131b80ba18,Jan Kassens,2025-06-16T16:22:47Z,Remove feature flag enableDO_NOT_USE_disableStrictPassiveEffect (#33524),5,109,114
facebook/react,6b7e207cabe4c1bc9390d862dd9228e94e9edf4b,lauren,2025-06-13T19:29:59Z,"[ci] Don't skip experimental prerelease incorrectly (#33527)  Previously the experimental workflow relied on the canary one running first to avoid race conditions. However, I didn't account for the fact that the canary one can now be skipped.",2,0,2
facebook/react,d60f77a533da830613431ddef83d0eda928697ad,lauren,2025-06-13T18:22:55Z,"[ci] Update prerelease workflows to allow publishing specific packages (#33525)  It may be useful at times to publish only specific packages as an experimental tag. For example, if we need to cherry pick some fixes for an old release, we can first do so by creating that as an experimental release just for that package to allow for quick testing by downstream projects.  Similar to .github/workflows/runtime_releases_from_npm_manual.yml I added three options (`dry`, `only_packages`, `skip_packages`) to `runtime_prereleases.yml` which both the manual and nightly workflows reuse. I also added a discord notification when the manual workflow is run.",84,2,86
facebook/react,12bc60f50989a7e10b96c6fad429af7739c537df,James Friend,2025-06-13T14:28:31Z,"[devtools] Added minimum indent size to Component Tree (#33517)  ## Summary  The devtools Components tab's component tree view currently has a behavior where the indentation of each level of the tree scales based on the available width of the view. If the view is narrow or component names are long, all indentation showing the hierarchy of the tree scales down with the view width until there is no indentation at all. This makes it impossible to see the nesting of the tree, making the tree view much less useful. With long component names and deep hierarchies this issue is particularly egregious. For comparison, the Chrome Dev Tools Elements panel uses a fixed indentation size, so it doesn't suffer from this issue.  This PR adds a minimum pixel value for the indentation width, so that even when the window is narrow some indentation will still be visible, maintaining the visual representation of the component tree hierarchy.  Alternatively, we could match the behavior of the Chrome Dev Tools and just use a constant indentation width.  ## How did you test this change?  - tests (yarn test-build-devtools) - tested in browser: - added an alternate left/right split pane layout to react-devtools-shell to test with (https://github.com/facebook/react/pull/33516) - tested resizing the tree view in different layout modes  ### before this change:    https://github.com/user-attachments/assets/470991f1-dc05-473f-a2cb-4f7333f6bae4  with a long component name:    https://github.com/user-attachments/assets/1568fc64-c7d7-4659-bfb1-9bfc9592fb9d      ### after this change:     https://github.com/user-attachments/assets/f60bd7fc-97f6-4680-9656-f0db3d155411  with a long component name:   https://github.com/user-attachments/assets/6ac3f58c-42ea-4c5a-9a52-c3b397f37b45",10,8,18
facebook/react,ed023cfc7304e4e02a79195c68601eff7606136a,James Friend,2025-06-13T14:25:04Z,"[devtools-shell] layout options for testing (#33516)  ## Summary  This PR adds a 'Layout' selector to the devtools shell main example, as well as a resizable split pane, allowing more realistic testing of how the devtools behaves when used in a vertical or horizontal layout and at different sizes (e.g. when resizing the Chrome Dev Tools pane).  ## How did you test this change?    https://github.com/user-attachments/assets/81179413-7b46-47a9-bc52-4f7ec414e8be",202,63,265
facebook/react,a00ca6f6b51e46a0ccec54a2231bfe7a1ed9ae1d,"Sebastian ""Sebbie"" Silbermann",2025-06-11T19:24:24Z,[Fizz] Delay detachment of completed boundaries until reveal (#33511),50,4,54
facebook/react,888ea60d8e6059790382c0b849be13915b4bcc30,lauren,2025-06-11T18:40:42Z,"[compiler][repro] Postfix operator is incorrectly compiled (#33508)  This bug was reported via our wg and appears to only affect values created as a ref.  Currently, postfix operators used in a callback gets compiled to:  ```js modalId.current = modalId.current + 1; // 1 const id = modalId.current; // 1 return id; ```  which is semantically incorrect. The postfix increment operator should return the value before incrementing. In other words something like this should have been compiled instead:  ```js const id = modalId.current; // 0 modalId.current = modalId.current + 1; // 1 return id; ```  This bug does not trigger when the incremented value is a plain primitive, instead there is a TODO bailout.",175,0,175
facebook/react,b7e2de632b2a160bc09edda1fbb9b8f85a6914e8,Jan Kassens,2025-06-11T16:08:04Z,Stringify context as SomeContext instead of SomeContext.Provider (#33507)  This matches the change in React 19 to use `<SomeContext>` as the preferred way to provide a context.,3,3,6
facebook/react,ff93c4448c44e8e5562a4102394ebf9f2b0ec847,Sebastian Markbåge,2025-06-11T16:07:10Z,"[Flight] Track Debug Info from Synchronously Unwrapped Promises (#33485)  Stacked on #33482.  There's a flaw with getting information from the execution context of the ping. For the soft-deprecated ""throw a promise"" technique, this is a bit unreliable because you could in theory throw the same one multiple times. Similarly, a more fundamental flaw with that API is that it doesn't allow for tracking the information of Promises that are already synchronously able to resolve.  This stops tracking the async debug info in the case of throwing a Promise and only when you render a Promise. That means some loss of data but we should just warn for throwing a Promise anyway.  Instead, this also adds support for tracking `use()`d thenables and forwarding `_debugInfo` from then. This is done by extracting the info from the Promise after the fact instead of in the resolve so that it only happens once at the end after the pings are done.  This also supports passing the same Promise in multiple places and tracking the debug info at each location, even if it was already instrumented with a synchronous value by the time of the second use.",845,161,1006
facebook/react,6c86e56a0fa3c8f253da133330cd5b7d1d20e7e5,Jan Kassens,2025-06-11T15:53:04Z,Remove feature flag enableRenderableContext (#33505)  The flag is fully rolled out.,48,292,340
facebook/react,56408a5b12fa4099e9dbbeca7f6bc59e1307e507,Sebastian Markbåge,2025-06-10T15:03:20Z,"[Flight] Emit timestamps only in forwards advancing time in debug info (#33482)  Previously you weren't guaranteed to have only advancing time entries, you could jump back in time, but now it omits unnecessary duplicates and clamps automatically if you emit a previous time entry to enforce forwards order only.  The reason I didn't do this originally is because `await` can jump in the order because we're trying to encode a graph into a flat timeline for simplicity of the protocol and consumers.  ```js async function a() {   await fetch1();   await fetch2(); }  async function b() {   await fetch3(); }  async function foo() {   const p = a();   await b();   return p; } ```  This can effectively create two parallel sequences:  ``` --1.................----2.......-- ------3......--------------------- ```  This can now be flattened to either:  ``` --1.................3---2.......-- ```  Or:  ``` ------3......1......----2.......-- ```  Depending on which one we visit first. Regardless, information is lost.  I'd say that the second one is worse encoding of this scenario because it pretends that we weren't waiting for part of the timespan that we were. To solve this I think we should probably make `emitAsyncSequence` create a temporary flat list and then sort it by start time before emitting.  Although we weren't actually blocked since there was some CPU time that was able to proceed to get to 3. So maybe the second one is actually better. If we wanted that consistently we'd have to figure out what the intersection was.  ---------  Co-authored-by: Hendrik Liebau <mail@hendrik-liebau.de>",670,252,922
facebook/react,c38e26897848374c34ac6b651fce4a9088ed4dd0,Sebastian Markbåge,2025-06-09T23:37:49Z,"[Fiber] Fix hydration of useId in SuspenseList (#33491)  Includes #31412.  The issue is that `pushTreeFork` stores some global state when reconcile children. This gets popped by `popTreeContext` in `completeWork`. Normally `completeWork` returns its own `Fiber` again if it wants to do a second pass which will call `pushTreeFork` again in the next pass. However, `SuspenseList` doesn't return itself, it returns the next child to work on.  The fix is to keep track of the count and push it again it when we return the next child to attempt.  There are still some outstanding issues with hydration. Like the backwards test still has the wrong behavior in it because it hydrates backwards and so it picks up the DOM nodes in reverse order. `tail=""hidden""` also doesn't work correctly.  There's also another issue with `useId` and `AsyncIterable` in SuspenseList when there's an unknown number of children. We don't support those showing one at a time yet though so it's not an issue yet. To fix it we need to add variable total count to the `useId` algorithm. E.g. by falling back to varint encoding.  ---------  Co-authored-by: Rick Hanlon <rickhanlonii@fb.com> Co-authored-by: Ricky <rickhanlonii@gmail.com>",390,2,392
facebook/react,80c03eb7e0f05da5e0de6faebbe8dbb434455454,Ruslan Lesiutin,2025-06-09T17:25:19Z,"refactor[devtools]: update css for settings and support css variables in shadow dom scnenario (#33487)  ## Summary  Minor changes around css and styling of Settings dialog.  1. `:root` selector was updated to `:is(:root, :host)` to make css variables available on Shadow Root 2. CSS tweaks around Settings dialog: removed references to deleted styles, removed unused styles, ironed out styling for cases when input styles are enhanced by user agent stylesheet  <!-- Explain the **motivation** for making this change. What existing problem does the pull request solve? -->  ## How did you test this change?  | Before | After | |--------|--------| | ![Screenshot 2025-06-09 at 15 35 55](https://github.com/user-attachments/assets/1ac5d002-744b-4b10-9501-d4f2a7c827d2) | ![Screenshot 2025-06-09 at 15 26 12](https://github.com/user-attachments/assets/8cc07cda-99a5-4930-973b-b139b193e349) | | ![Screenshot 2025-06-09 at 15 36 02](https://github.com/user-attachments/assets/1af4257c-928d-4ec6-a614-801cc1936f4b) | ![Screenshot 2025-06-09 at 15 26 25](https://github.com/user-attachments/assets/7a3a0f7c-5f3d-4567-a782-dd37368a15ae) | | ![Screenshot 2025-06-09 at 15 36 05](https://github.com/user-attachments/assets/a1e00381-2901-4e22-b1c6-4a3f66ba78c9) | ![Screenshot 2025-06-09 at 15 26 30](https://github.com/user-attachments/assets/bdefce68-cbb5-4b88-b44c-a74f28533f7d) | | ![Screenshot 2025-06-09 at 15 36 12](https://github.com/user-attachments/assets/4eda6234-0ef0-40ca-ad9d-5990a2b1e8b4) | ![Screenshot 2025-06-09 at 15 26 37](https://github.com/user-attachments/assets/5cac305e-fd29-460c-b0b8-30e477b8c26e) |",88,80,168
facebook/react,b6c0aa88140bba2a61c1de16bda2505c89b26235,Wesley LeMahieu,2025-06-09T15:40:27Z,"[compiler]: fix link compiler & 4 broken tests from path containing spaces (#33409)  ## Summary  Problem #1: Running the `link-compiler.sh` bash script via `""prebuild""` script fails if a developer has cloned the `react` repo into a folder that contains _any_ spaces. 3 tests fail because of this.  <img width=""1003"" alt=""fail-1"" src=""https://github.com/user-attachments/assets/1fbfa9ce-4f84-48d7-b49c-b6e967b8c7ca"" /> <img width=""1011"" alt=""fail-2"" src=""https://github.com/user-attachments/assets/0a8c6371-a2df-4276-af98-38f4784cf0da"" /> <img width=""1027"" alt=""fail-3"" src=""https://github.com/user-attachments/assets/1c4f4429-800c-4b44-b3da-a59ac85a16b9"" />  For example, my current folder is: `/Users/wes/Development/Open Source Contributions/react`  The link compiler error returns: `./scripts/react-compiler/link-compiler.sh: line 15: cd: /Users/wes/Development/Open: No such file or directory`  Problem #2: 1 test in `ReactChildren-test.js` fails due the existing stack trace regex which should be lightly revised.  `([^(\[\n]+)[^\n]*/g` is more robust for stack traces: it captures the function/class name (with dots) and does not break on spaces in file paths. `([\S]+)[^\n]*/g` is simpler but breaks if there are spaces and doesn't handle dotted names well.  Additionally, we trim the whitespace off the name to resolve extra spaces breaking this test as well:  ``` -     in div (at **) +     in div  (at **) ```  <img width=""987"" alt=""fail-4"" src=""https://github.com/user-attachments/assets/56a673bc-513f-4458-95b2-224129c77144"" />  All of the above tests pass if I hyphenate my local folder: `/Users/wes/Development/Open-Source-Contributions/react`  I selfishly want to keep spaces in my folder names. 🫣  ## How did you test this change?  **npx yarn prebuild**  Before: <img width=""896"" alt=""Screenshot at Jun 01 11-42-56"" src=""https://github.com/user-attachments/assets/4692775c-1e5c-4851-9bd7-e12ed5455e47"" />  After: <img width=""420"" alt=""Screenshot at Jun 01 11-43-42"" src=""https://github.com/user-attachments/assets/4e303c00-02b7-4540-ba19-927b2d7034fb"" />  **npx yarn test** **npx yarn test ./packages/react/src/\_\_tests\_\_/ReactChildren-test.js** **npx yarn test -r=xplat --env=development --variant=true --ci --shard=3/5**  Before: <img width=""438"" alt=""before"" src=""https://github.com/user-attachments/assets/f5eedb22-18c3-4124-a04b-daa95c0f7652"" />  After: <img width=""439"" alt=""after"" src=""https://github.com/user-attachments/assets/a94218ba-7c6a-4f08-85d3-57540e9d0029"" />  <img width=""650"" alt=""Screenshot at Jun 02 18-03-39"" src=""https://github.com/user-attachments/assets/3eae993c-a56b-46c8-ae02-d249cb053fe7"" />  <img width=""685"" alt=""Screenshot at Jun 03 12-53-47"" src=""https://github.com/user-attachments/assets/5b2caa33-d3dc-4804-981d-52cb10b6226f"" />",5,4,9
facebook/react,428ab8200128d9421828dbe644c3448d21ea8c45,Sebastian Markbåge,2025-06-09T14:04:40Z,"[Flight] Simulate fetch to third party in fixture (#33484)  This adds some I/O to go get the third party thing to test how it overlaps.  With #33482, this is what it looks like. The await gets cut off when the third party component starts rendering. I.e. after the latency to start.  <img width=""735"" alt=""Screenshot 2025-06-08 at 5 42 46 PM"" src=""https://github.com/user-attachments/assets/f68d9a84-05a1-4125-b3f0-8f3e4eaaa5c1"" />  This doesn't fully simulate everything because it should actually also simulate each chunk of the stream coming back too. We could wrap the ReadableStream to simulate that. In that scenario, it would probably get some awaits on the chunks at the end too.",26,7,33
facebook/react,4df098c4c2c51a033592ebc84abc47cc49a6bfb2,Jordan Brown,2025-06-09T13:26:45Z,[compiler] Don't include useEffectEvent values in autodeps (#33450)  Summary: useEffectEvent values are not meant to be added to the dep array,109,1,110
facebook/react,95bcf87e6b29f4efee26d0a79cbdc84776180cce,Hendrik Liebau,2025-06-09T11:42:10Z,"Format `ReactNativeAttributePayloadFabric.js` with Prettier (#33486)  The prettier check for this file is currently failing on `main`, after #32119 was merged.",3,1,4
facebook/react,911dbd9e34048b21e96f24acb837b926687aa939,Hanno J. Gödecke,2025-06-09T09:55:28Z,"feat(ReactNative): prioritize attribute config `process` function to allow processing function props (#32119)  ## Summary  In react-native props that are passed as function get converted to a boolean (`true`). This is the default pattern for event handlers in react-native. However, there are reasons for why you might want to opt-out of this behavior, and instead, pass along the actual function as the prop. Right now, there is no way to do this, and props that are functions always get set to `true`. The `ViewConfig` attributes already have the API for a `process` function. I simply moved the check for the process function up, so if a ViewConfig's prop attribute configured a process function this is always called first. This provides an API to opt out of the default behavior.   This is the accompanied PR for react-native:  - https://github.com/facebook/react-native/pull/48777  ## How did you test this change?  <!-- Demonstrate the code is solid. Example: The exact commands you ran and their output, screenshots / videos if the pull request changes the user interface. How exactly did you verify that your PR solves the issue you wanted to solve?   If you leave this empty, your PR will very likely be closed. -->  I modified the code manually in a template react-native app and confirmed its working. This is a code path you only need in very special cases, thus it's a bit hard to provide a test for this. I recorded a video where you can see that the changes are active and the prop is being passed as native value.  For this I created a custom native component with a view config that looked like this:  ```js const viewConfig = {   uiViewClassName: 'CustomView',   bubblingEventTypes: {},   directEventTypes: {},   validAttributes: {     nativeProp: {       process: (nativeProp) => { 		// Identity function that simply returns the prop function callback         // to opt out of this prop being set to `true` as its a function         return nativeProp       },     },   }, } ```    https://github.com/user-attachments/assets/493534b2-a508-4142-a760-0b1b24419e19  Additionally I made sure that this doesn't conflict with any existing view configs in react native. In general, this shouldn't be a breaking change, as for existing view configs it didn't made a difference if you simply set `myProp: true` or `myProp: { process: () => {...} }` because as soon as it was detected that the prop is a function the config wouldn't be used (which is what this PR fixes). Probably everyone, including the react-native core components use `myProp: true` for callback props, so this change should be fine.",51,19,70
facebook/react,c0b5a0cad32cbf237d4c0134bef702d6ba3e393c,Hendrik Liebau,2025-06-08T04:33:25Z,[Flight] Use Web Streams APIs for 3rd-party component in Flight fixture (#33481),21,31,52
facebook/react,e4b88ae4c6c30791b6c1c2794d5a8e32ed19c931,Hendrik Liebau,2025-06-07T21:39:25Z,[Flight] Add Web Streams APIs to unbundled Node entries for Webpack (#33480),10,3,13
facebook/react,6c8bcdaf1b0c3340150e174a342429d94e729fbb,Sebastian Markbåge,2025-06-07T21:26:36Z,"[Flight] Clarify Semantics for Awaiting Cached Data (#33438)  Technically the async call graph spans basically all the way back to the start of the app potentially, but we don't want to include everything. Similarly we don't want to include everything from previous components in every child component. So we need some heuristics for filtering out data.  We roughly want to be able to inspect is what might contribute to a Suspense loading sequence even if it didn't this time e.g. due to a race condition.  One flaw with the previous approach was that awaiting a cached promise in a sibling that happened to finish after another sibling would be excluded. However, in a different race condition that might end up being used so I wanted to include an empty ""await"" in that scenario to have some association from that component.  However, for data that resolved fully before the request even started, it's a little different. This can be things that are part of the start up sequence of the app or externally cached data. We decided that this should be excluded because it doesn't contribute to the loading sequence in the expected scenario. I.e. if it's cached. Things that end up being cache misses would still be included. If you want to test externally cached data misses, then it's up to you or the framework to simulate those. E.g. by dropping the cache. This also helps free up some noise since static / cached data can be excluded in visualizations.  I also apply this principle to forwarding debug info. If you reuse a cached RSC payload, then the Server Component render time and its awaits gets clamped to the caller as if it has zero render/await time. The I/O entry is still back dated but if it was fully resolved before we started then it's completely excluded.",602,177,779
facebook/react,b367b60927dd85239852bfee60715034c7ca97ba,Sebastian Markbåge,2025-06-07T15:28:57Z,"[Flight] Add ""use ..."" boundary after the change instead of before it (#33478)  I noticed that the ThirdPartyComponent in the fixture was showing the wrong stack and the `""use third-party""` is in the wrong location.  <img width=""628"" alt=""Screenshot 2025-06-06 at 11 22 11 PM"" src=""https://github.com/user-attachments/assets/f0013380-d79e-4765-b371-87fd61b3056b"" />  When creating the initial JSX inside the third party server, we should make sure that it has no owner. In a real cross-server environment you get this by default by just executing in different context. But since the fixture example is inside the same AsyncLocalStorage as the parent it already has an owner which gets transferred. So we should make sure that were we create the JSX has no owner to simulate this.  When we then parse a null owner on the receiving side, we replace its owner/stack with the owner/stack of the call to `createFrom...` to connect them. This worked fine with only two environments. The bug was that when we did this and then transferred the result to a third environment we took the original parsed stack trace. We should instead parse a new one from the replaced stack in the current environment.  The second bug was that the `""use third-party""` badge ends up in the wrong place when we do this kind of thing. Because the stack of the thing entering the new environment is the call to `createFrom...` which is in the old environment even though the component itself executes in the new environment. So to see if there's a change we should be comparing the current environment of the task to the owner's environment instead of the next environment after the task.  After:  <img width=""494"" alt=""Screenshot 2025-06-07 at 1 13 28 AM"" src=""https://github.com/user-attachments/assets/e2e870ba-f125-4526-a853-bd29f164cf09"" />",152,138,290
facebook/react,9666605abfee7e525a22931ce38d40bb29ddc8a5,Sebastian Markbåge,2025-06-07T14:40:09Z,[Flight] Add Web Stream support to the Flight Server in Node (#33474)  This needs some tweaks to the implementation and a conversion but simple enough.  ---------  Co-authored-by: Hendrik Liebau <mail@hendrik-liebau.de>,696,27,723
facebook/react,65ec57df3781d2c62456bb136c7f160f7e834492,Sebastian Markbåge,2025-06-07T00:16:43Z,[Fizz] Add Web Streams to Fizz Node entry point (#33475)  New take on #33441.  This uses a wrapper instead of a separate bundle.,503,9,512
facebook/react,b3d5e9078685c000e7e9ee3668a7a4b4f3256b1f,"Sebastian ""Sebbie"" Silbermann",2025-06-07T00:11:33Z,[Fizz] Include unit of threshold in rel=expect deopt error (#33476),3,3,6
facebook/react,280ff6fed2a84b6ad7588c72d3e66b20f0f3c91a,Sebastian Markbåge,2025-06-06T21:14:15Z,"[Flight] Add Web Stream support to the Flight Client in Node (#33473)  This effectively lets us consume Web Streams in a Node build. In fact the Node entry point is now just adding Node stream APIs.  For the client, this is simple because the configs are not actually stream type specific. The server is a little trickier.",8,37,45
facebook/react,82f3684c63fd60fdacbe4d536214596ffd7a465f,Sebastian Markbåge,2025-06-06T20:26:36Z,"Revert Node Web Streams (#33472)  Reverts #33457, #33456 and #33442.  There are too many issues with wrappers, lazy init, stateful modules, duplicate instantiation of async_hooks and duplication of code.  Instead, we'll just do a wrapper polyfill that uses Node Streams internally.  I kept the client indirection files that I added for consistency with the server though.",19,977,996
facebook/react,142aa0744d0e73dc5390bc19d4d41dd8aeda2b19,Josh Story,2025-06-06T18:59:15Z,"[Fizz] Support deeply nested Suspense inside fallback (#33467)  When deeply nested Suspense boundaries inside a fallback of another boundary resolve it is possible to encounter situations where you either attempt to flush an aborted Segment or you have a boundary without any root segment. We intended for both of these conditions to be impossible to arrive at legitimately however it turns out in this situation you can. The fix is two-fold  1. allow flushing aborted segments by simply skipping them. This does remove some protection against future misconfiguraiton of React because it is no longer an invariant that you hsould never attempt to flush an aborted segment but there are legitimate cases where this can come up and simply omitting the segment is fine b/c we know that the user will never observe this. A semantically better solution would be to avoid flushing boudaries inside an unneeded fallback but to do this we would need to track all boundaries inside a fallback or create back pointers which add to memory overhead and possibly make GC harder to do efficiently. By flushing extra we're maintaining status quo and only suffer in performance not with broken semantics.  2. when queuing completed segments allow for queueing aborted segments and if we are eliding the enqueued segment allow for child segments that are errored to be enqueued too. This will mean that we can maintain the invariant that a boundary must have a root segment the first time we flush it, it just might be aborted (see point 1 above).  This change has two seemingly similar test cases to exercise this fix. The reason we need both is that when you have empty segments you hit different code paths within Fizz and so each one (without this fix) triggers a different error pathway.  This change also includes a fix to our tests where we were not appropriately setting CSPnonce back to null at the start of each test so in some contexts scripts would not run for some tests",119,4,123
facebook/react,6ccf328499f06c140ffe96a096744c22319394cc,Sebastian Markbåge,2025-06-06T18:01:15Z,"[Fizz] Shorten throttle to hit a specific target metric (#33463)  Adding throttling or delaying on images, can obviously impact metrics. However, it's all in the name of better actual user experience overall. (Note that it's not strictly worse even for metric. Often it's actually strictly better due to less work being done overall thanks to batching.)  Metrics can impact things like search ranking but I believe this is on a curve. If you're already pretty good, then a slight delay won't suddenly make you rank in a completely different category. Similarly, if you're already pretty bad then a slight delay won't make it suddenly way worse. It's still in the same realm. It's just one weight of many. I don't think this will make a meaningful practical impact and if it does, that's probably a bug in the weights that will get fixed.  However, because there's a race to try to ""make everything green"" in terms of web vitals, if you go from green to yellow only because of some throttling or suspensey images, it can feel bad. Therefore this implements a heuristic where if the only reason we'd miss a specific target is because of throttling or suspensey images, then we shorten the timeout to hit the metric. This is a worse user experience because it can lead to extra flashing but feeling good about ""green"" matters too.  If you then have another reveal that happens to be the largest contentful paint after that, then that's throttled again so that it doesn't become flashy after that. If you've already missed the deadline then you're not going to hit your metric target anyway. It can affect average but not median.  This is mainly about LCP. It doesn't affect FCP since that doesn't have a throttle. If your LCP is the same as your FCP then it also doesn't matter.  We assume that `performance.now()`'s zero point starts at the ""start of the navigation"" which makes this simple. Even if we used the `PerformanceNavigationTiming` API it would just tell us the same thing.  This only implements for Fizz since these metrics tend to currently only by tracked for initial loads, but with soft navs tracking we could consider implementing the same for Fiber throttles.",30,8,38
facebook/react,a374e0ec87ec1d45a94b69e26c747529ea5dbab0,lauren,2025-06-06T17:32:51Z,[ci] Fix missing permissions for stale job (#33466)  Missed these the last time.,4,1,5
facebook/react,ab859e31be5db56106161060033109c9f2d26eca,Sebastian Markbåge,2025-06-06T15:07:40Z,[Flight] Build Node.js Web Streams builds for Turbopack and Parcel (#33457)  Same as #33456 and #33442 but for Turbopack and Parcel.,318,29,347
facebook/react,e8d15fa19efcd18f0947fe4189652f5b64f74256,Sebastian Markbåge,2025-06-06T15:07:15Z,"[Flight] Build node-webstreams version of bundled webpack server (#33456)  Follow up to #33442. This is the bundled version.  To keep type check passes from exploding and the maintainance of the annoying `paths: []` list small, this doesn't add this to flow type checks. We might miss some config but every combination should already be covered by other one passes.  I also don't add any jest tests because to test these double export entry points we need conditional importing to cover builds and non-builds which turns out to be difficult for the Flight builds so these aren't covered by any basic build tests.  This approach is what I'm going for, for the other bundlers too.",124,7,131
facebook/react,d177272802b7f86a847312c23b7e60a6f56434de,Sebastian Markbåge,2025-06-06T14:29:48Z,"[Fizz] Error and deopt from rel=expect for large documents without boundaries (#33454)  We want to make sure that we can block the reveal of a well designed complete shell reliably. In the Suspense model, client transitions don't have any way to implicitly resolve. This means you need to use Suspense or SuspenseList to explicitly split the document. Relying on implicit would mean you can't add a Suspense boundary later where needed. So we highly encourage the use of them around large content.  However, if you have constructed a too large shell (e.g. by not adding any Suspense boundaries at all) then that might take too long to render on the client. We shouldn't punish users (or overzealous metrics tracking tools like search engines) in that scenario.  This opts out of render blocking if the shell ends up too large to be intentional and too slow to load. Instead it deopts to showing the content split up in arbitrary ways (browser default). It only does this for SSR, and not client navs so it's not reliable.  In fact, we issue an error to `onError`. This error is recoverable in that the document is still produced. It's up to your framework to decide if this errors the build or just surface it for action later.  What should be the limit though? There's a trade off here. If this limit is too low then you can't fit a reasonably well built UI within it without getting errors. If it's too high then things that accidentally fall below it might take too long to load.  I came up with 512kB of uncompressed shell HTML. See the comment in code for the rationale for this number. TL;DR: Data and theory indicates that having this much content inside `rel=""expect""` doesn't meaningfully change metrics. Research of above-the-fold content on various websites indicate that this can comfortable fit all of them which should be enough for any intentional initial paint.",199,64,263
facebook/react,22b929156c325eaf52c375f0c62801831951814a,Sebastian Markbåge,2025-06-06T14:14:13Z,"[Fizz] Suspensey Images for View Transition Reveals (#33433)  Block the view transition on suspensey images Up to 500ms just like the client.  We can't use `decode()` because a bug in Chrome where those are blocked on `startViewTransition` finishing we instead rely on sync decoding but also that the image is live when it's animating in and we assume it doesn't start visible.  However, we can block the View Transition from starting on the `""load""` or `""error""` events.  The nice thing about blocking inside `startViewTransition` is that we have already done the layout so we can only wait on images that are within the viewport at this point. We might want to do that in Fiber too. If many image doesn't have fixed size but need to load first, they can all end up in the viewport. We might consider only doing this for images that have a fixed size or only a max number that doesn't have a fixed size.",41,10,51
facebook/react,a3be6829c6425f306a8bef9f7dba72d1347a64b3,Ricky,2025-06-06T13:16:58Z,[tests] remove pretest compiler script (#33452)  This shouldn't be needed now that the lint rule was move,30,1,31
facebook/react,b1759882c0b8045aff27fa9e41600534d396f69c,Hendrik Liebau,2025-06-06T04:42:58Z,[Flight] Bypass caches in Flight fixture if requested (#33445),21,15,36
facebook/react,dddcae7a11b8241cbd6e2de55f9e68881baea458,Timothy Yung,2025-06-05T21:22:35Z,"Enable the `enableEagerAlternateStateNodeCleanup` Feature Flag (#33447)  ## Summary  Enables the `enableEagerAlternateStateNodeCleanup` feature flag for all variants, while maintaining the `__VARIANT__` for the internal React Native flavor for backtesting reasons.  ## How did you test this change?  ``` $ yarn test ```",5,5,10
facebook/react,43714eb4e970d0200fdc5eac887691df7fae53d5,Hendrik Liebau,2025-06-05T19:08:57Z,"Do not notify Discord for draft pull requests (#33446)  When I added the `ready_for_review` event in #32344, no notifications for opened draft PRs were sent due to some other condition. This is not the case anymore, so we need to exclude draft PRs from triggering a notification when the workflow is run because of an `opened` event. This event is still needed because the `ready_for_review` event only fires when an existing draft PR is converted to a non-draft state. It does not trigger for pull requests that are opened directly as ready-for-review.",2,0,2
facebook/react,a5110b22f0a02cb87cd2bca5dc4527c73e2f281b,Sebastian Markbåge,2025-06-05T18:29:02Z,[Flight] Add a Node.js Web Streams bundle for unbundled client/server for Webpack (#33442)  Like #33441 but for Flight.  This is just one of the many combinations needed. I'm just starting with one.,167,13,180
facebook/react,b4477d3800ccb0bdf26670cd1f021d094159c38f,Hendrik Liebau,2025-06-05T15:19:54Z,"[Flight] Add a cached 3rd-party component to the Flight fixture (#33443)  This should allow us to visualize what https://github.com/facebook/react/pull/33438 is trying to convey.  An uncached 3rd-party component is displayed like this in the dev tools:  <img width=""1072"" alt=""Screenshot 2025-06-05 at 12 57 32"" src=""https://github.com/user-attachments/assets/d418ae23-d113-4dc9-98b8-ab426710454a"" />  However, when the component is restored from a cache, it looks like this:  <img width=""1072"" alt=""Screenshot 2025-06-05 at 12 56 56"" src=""https://github.com/user-attachments/assets/a0e34379-d8c0-4b14-8b54-b5c06211232b"" />  The `Server Components ⚛` track is missing completely here, and the `Loading profile...` phase also took way longer than without caching the 3rd-party component.  On `main`, the `Server Components ⚛` track is not missing:  <img width=""1072"" alt=""Screenshot 2025-06-05 at 14 31 20"" src=""https://github.com/user-attachments/assets/c35e405d-27ca-4b04-a34c-03bd959a7687"" />  The cached 3rd-party component starts before the current render, and is also not excluded here, which is of course expected without #33438.",45,0,45
facebook/react,93f1668045b924294f5832d5044fa049cd7af16e,Sebastian Markbåge,2025-06-05T14:50:41Z,"[Fizz] Add Node Web Streams bundle for SSR (#33441)  We highly recommend using Node Streams in Node.js because it's much faster and it is less likely to cause issues when chained in things like compression algorithms that need explicit flushing which the Web Streams ecosystem doesn't have a good solution for. However, that said, people want to be able to use the worse option for various reasons.  The `.edge` builds aren't technically intended for Node.js. A Node.js environments needs to be patched in various ways to support it. It's also less optimal since it can't use [Node.js exclusive features](https://github.com/facebook/react/pull/33388) and have to use [the lowest common denominator](https://github.com/facebook/react/pull/27399) such as JS implementations instead of native.  This adds a Web Streams build of Fizz but exclusively for Node.js so that in it we can rely on Node.js modules. The main difference compared to Edge is that SSR now uses `createHash` from the `""crypto""` module and imports `TextEncoder` from `""util""`. We use `setImmediate` instead of `setTimeout`.  The public API is just `react-dom/server` which in Node.js automatically imports `react-dom/server.node` which re-exports the legacy bundle, Node Streams bundle and Node Web Streams bundle. The main downside is if your bundler isn't smart to DCE this barrel file.  With Flight the difference is larger but that's a bigger lift.",557,12,569
facebook/react,37054867c15a7381abe0f73d98f3fecd06da52da,Sebastian Markbåge,2025-06-04T04:49:03Z,"[Flight] Forward debugInfo from awaited instrumented Promises (#33415)  Stacked on #33403.  When a Promise is coming from React such as when it's passed from another environment, we should forward the debug information from that environment. We already do that when rendered as a child.  This makes it possible to also `await promise` and have the information from that instrumented promise carry through to the next render.  This is a bit tricky because the current protocol is that we have to read it from the Promise after it resolves so it has time to be assigned to the promise. `async_hooks` doesn't pass us the instance (even though it has it) when it gets resolved so we need to keep it around. However, we have to be very careful because if we get this wrong it'll cause a memory leak since we retain things by `asyncId` and then manually listen for `destroy()` which can only be called once a Promise is GC:ed, which it can't be if we retain it. We have to therefore use a `WeakRef` in case it never resolves, and then read the `_debugInfo` when it resolves. We could maybe install a setter or something instead but that's also heavy.  The other issues is that we don't use native Promises in ReactFlightClient so our instrumented promises aren't picked up by the `async_hooks` implementation and so we never get a handle to our thenable instance. To solve this we can create a native wrapper only in DEV.",733,92,825
facebook/react,d742611ce40545127032f4e221c78bf9f70eb437,Sebastian Markbåge,2025-06-03T21:40:30Z,"Replace Implicit Options on SuspenseList with Explicit Options (#33424)  We want to change the defaults for `revealOrder` and `tail` on SuspenseList. This is an intermediate step to allow experimental users to upgrade.  To explicitly specify these options I added `revealOrder=""independent""` and `tail=""visible""`.  I then added warnings if `undefined` or `null` is passed. You must now always explicitly specify them. However, semantics are still preserved for now until the next step.  We also want to change the rendering order of the `children` prop for `revealOrder=""backwards""`. As an intermediate step I first added `revealOrder=""unstable_legacy-backwards""` option. This will only be temporary until all users can switch to the new `""backwards""` semantics once we flip it in the next step.  I also clarified the types that the directional props requires iterable children but not iterable inside of those. Rows with multiple items can be modeled as explicit fragments.",397,72,469
facebook/react,154008172573d64519ebbc23da611a27073b0a8c,Sebastian Markbåge,2025-06-03T21:30:31Z,"[Flight] Encode Async I/O Tasks using the Enclosing Line/Column (#33403)  Stacked on #33402.  There's a bug in Chrome Performance tracking which uses the enclosing line/column instead of the callsite in stacks.  For our fake eval:ed functions that represents functions on the server, we can position the enclosing function body at the position of the callsite to simulate getting the right line.  Unfortunately, that doesn't give us exactly the right callsite when it's used for other purposes that uses the callsite like console logs and error reporting and stacks inside breakpoints. So I don't think we want to always do this.  For ReactAsyncInfo/ReactIOInfo, the only thing we're going to use the fake task for is the Performance tracking, so it doesn't have any downsides until Chrome fixes the bug and we'd have to revert it. Therefore this PR uses that techniques only for those entries.  We could do this for Server Components too but we're going to use those for other things too like console logs. I don't think it's worth duplicating the Task objects. That would also make it inconsistent with Client Components.  For Client Components, we could in theory also generate fake evals but that would be way slower since there's so many of them and currently we rely on the native implementation for those. So doesn't seem worth fixing.  But since we can at least fix it for RSC I/O/awaits we can do this hack.",38,5,43
facebook/react,9cc74fec749bcca2e0f5d1e41aa612b2135641ff,Sebastian Markbåge,2025-06-03T21:29:41Z,"[Flight] Emit the time we awaited something inside a Server Component (#33402)  Stacked on #33400.   <img width=""1261"" alt=""Screenshot 2025-06-01 at 10 27 47 PM"" src=""https://github.com/user-attachments/assets/a5a73ee2-49e0-4851-84ac-e0df6032efb5"" />  This is emitted with the start/end time and stack of the ""await"". Which may be different than the thing that started the I/O.  These awaits aren't quite as simple as just every await since you can start a sequence in parallel there can actually be multiple overlapping awaits and there can be CPU work interleaved with the await on the same component.  ```js function getData() {   await fetch(...);   await fetch(...); } const promise = getData(); doWork(); await promise; ```  This has two ""I/O"" awaits but those are actually happening in parallel with `doWork()`.  Since these also could have started before we started rendering this sequence (e.g. a component) we have to clamp it so that we don't consider awaits that start before the component.  What we're conceptually trying to convey is the time this component was blocked due to that I/O resource. Whether it's blocked from completing the last result or if it's blocked from issuing a waterfall request.",138,19,157
facebook/react,157ac578ded11352330dbdfb8cf339b28c6a16d6,Sebastian Markbåge,2025-06-03T21:28:46Z,[Flight] Include env in ReactAsyncInfo and ReactIOInfo (#33400)  Stacked on #33395.  This lets us keep track of which environment this was fetched and awaited.  Currently the IO and await is in the same environment. It's just kept when forwarded. Once we support forwarding information from a Promise fetched from another environment and awaited in this environment then the await can end up being in a different environment.  There's a question of when the await is inside Flight itself such as when you return a promise fetched from another environment whether that should mean that the await is in the current environment. I don't think so since the original stack trace is the best stack trace. It's only if you `await` it in user space in this environment first that this might happen and even then it should only be considered if there wasn't a better await earlier or if reading from the other environment was itself I/O.  The timing of *when* we read `environmentName()` is a little interesting here too.,52,14,66
facebook/react,45da4e055dc7a2b9de6abdae0709e242f8091636,Sebastian Markbåge,2025-06-03T20:12:26Z,"[Flight] Track Owner on AsyncInfo and IOInfo (#33395)  Stacked on #33394.  This lets us create async stack traces to the owner that was in context when the I/O was started or awaited.  <img width=""615"" alt=""Screenshot 2025-06-01 at 12 31 52 AM"" src=""https://github.com/user-attachments/assets/6ff5a146-33d6-4a4b-84af-1b57e73047d4"" />  This owner might not be the immediate closest parent where the I/O was awaited.",154,33,187
facebook/react,d8919a0a6854715a4a77db24ed7a94a124487d86,Sebastian Markbåge,2025-06-03T19:31:12Z,"[Flight] Log ""Server Requests"" Track (#33394)  Stacked on #33392.  This adds another track to the Performance Track called `""Server Requests""`.  <img width=""1015"" alt=""Screenshot 2025-06-01 at 12 02 14 AM"" src=""https://github.com/user-attachments/assets/c4d164c4-cfdf-4e14-9a87-3f011f65fd20"" />  This logs the flat list of I/O awaited on by Server Components. There will be other views that are more focused on what data blocks a specific Component or Suspense boundary but this is just the list of all the I/O basically so you can get an overview of those waterfalls without the noise of all the Component trees and rendering. It's similar to what the ""Network"" track is on the client.  I've been going back and forth on what to call this track but I went with `""Server Requests""` for now. The idea is that the name should communicate that this is something that happens on the server and is a pairing with the `""Server Components""` track. Although we don't use that feature, since it's missing granularity, it's also similar to ""Server Timings"".",67,3,70
facebook/react,2e9f8cd3e031212bc507e31e2888f8f96b1de138,"Sebastian ""Sebbie"" Silbermann",2025-06-03T19:10:13Z,Clear bundler cache before bundling fixtures (#33426),10,10,20
facebook/react,65a46c7eebb731ba5c1602afef87365491beb75d,Sebastian Markbåge,2025-06-03T19:04:28Z,"[Flight] Track the function name that was called for I/O entries (#33392)  Stacked on #33390.  The stack trace doesn't include the thing you called when calling into ignore listed content. We consider the ignore listed content conceptually the abstraction that you called that's interesting.  This extracts the name of the first ignore listed function that was called from user space. For example `""fetch""`. So we can know what kind of request this is.  This could be enhanced and tweaked with heuristics in the future. For example, when you create a Promise yourself and call I/O inside of it like my `delay` examples, then we use that Promise as the I/O node but its stack doesn't have the actual I/O performed. It might be better to use the inner I/O node in that case. E.g. `setTimeout`. Currently I pick the name from the first party code instead - in my example `delay`.  Another case that could be improved is the case where your whole component is third-party. In that case we still log the I/O but it has no context about what kind of I/O since the whole stack is ignored it just gets the component name for example. We could for example look at the first name that is in a different package than the package name of the ignored listed component. So if `node_modules/my-component-library/index.js` calls into `node_modules/mysql/connection.js` then we could use the name from the inner.",120,55,175
facebook/react,3fb17d16a4838e132d0d6dbb08f91b7e7da691eb,Sebastian Markbåge,2025-06-03T18:16:34Z,"[Flight] Encode ReactIOInfo as its own row type (#33390)  Stacked on #33388.  This encodes the I/O entries as their own row type (`""J""`). This makes it possible to parse them directly without first parsing the debug info for each component. E.g. if you're just interested in logging the I/O without all the places it was awaited.  This is not strictly necessary since the debug info is also readily available without parsing the actual trees. (That's how the Server Components Performance Track works.) However, we might want to exclude this information in profiling builds while retaining some limited form of I/O tracking.  It also allows for logging side-effects that are not awaited if we wanted to.",145,64,209
facebook/react,acee65d6d031697ab8c71932a5b028351cbc3b03,Sebastian Markbåge,2025-06-03T18:14:40Z,"[Flight] Track Awaits on I/O as Debug Info (#33388)  This lets us track what data each Server Component depended on. This will be used by Performance Track and React DevTools.  We use Node.js `async_hooks`. This has a number of downside. It is Node.js specific so this feature is not available in other runtimes until something equivalent becomes available. It's [discouraged by Node.js docs](https://nodejs.org/api/async_hooks.html#async-hooks). It's also slow which makes this approach only really viable in development mode. At least with stack traces. However, it's really the only solution that gives us the data that we need.  The [Diagnostic Channel](https://nodejs.org/api/diagnostics_channel.html) API is not sufficient. Not only is many Node.js built-in APIs missing but all libraries like databases are also missing. Were as `async_hooks` covers pretty much anything async in the Node.js ecosystem.  However, even if coverage was wider it's not actually showing the information we want. It's not enough to show the low level I/O that is happening because that doesn't provide the context. We need the stack trace in user space code where it was initiated and where it was awaited. It's also not each low level socket operation that we want to surface but some higher level concept which can span a sequence of I/O operations but as far as user space is concerned.  Therefore this solution is anchored on stack traces and ignore listing to determine what the interesting span is. It is somewhat Promise-centric (and in particular async/await) because it allows us to model an abstract span instead of just random I/O. Async/await points are also especially useful because this allows Async Stacks to show the full sequence which is not supported by random callbacks. However, if no Promises are involved we still to our best to show the stack causing plain I/O callbacks.  Additionally, we don't want to track all possible I/O. For example, side-effects like logging that doesn't affect the rendering performance doesn't need to be included. We only want to include things that actually block the rendering output. We also need to track which data blocks each component so that we can track which data caused a particular subtree to suspend.  We can do this using `async_hooks` because we can track the graph of what resolved what and then spawned what.  To track what suspended what, something has to resolve. Therefore it needs to run to completion before we can show what it was suspended on. So something that never resolves, won't be tracked for example.  We use the `async_hooks` in `ReactFlightServerConfigDebugNode` to build up an `ReactFlightAsyncSequence` graph that collects the stack traces for basically all I/O and Promises allocated in the whole app. This is pretty heavy, especially the stack traces, but it's because we don't know which ones we'll need until they resolve. We don't materialize the stacks until we need them though.  Once they end up pinging the Flight runtime, we collect which current executing task that pinged the runtime and then log the sequence that led up until that runtime into the RSC protocol. Currently we only include things that weren't already resolved before we started rendering this task/component, so that we don't log the entire history each time.  Each operation is split into two parts. First a `ReactIOInfo` which represents an I/O operation and its start/end time. Basically the start point where it was start. This is basically represents where you called `new Promise()` or when entering an `async function` which has an implied Promise. It can be started in a different component than where it's awaited and it can be awaited in multiple places. Therefore this is global information and not associated with a specific Component.  The second part is `ReactAsyncInfo`. This represents where this I/O was `await`:ed or `.then()` called. This is associated with a point in the tree (usually the Promise that's a direct child of a Component). Since you can have multiple different I/O awaited in a sequence technically it forms a dependency graph but to simplify the model these awaits as flattened into the `ReactDebugInfo` list. Basically it contains each await in a sequence that affected this part from unblocking.  This means that the same `ReactAsyncInfo` can appear in mutliple components if they all await the same `ReactIOInfo` but the same Promise only appears once.  Promises that are only resolved by other Promises or immediately are not considered here. Only if they're resolved by an I/O operation. We pick the Promise basically on the border between user space code and ignored listed code (`node_modules`) to pick the most specific span but abstract enough to not give too much detail irrelevant to the current audience. Similarly, the deepest `await` in user space is marked as the relevant `await` point.  This feature is only available in the `node` builds of React. Not if you use the `edge` builds inside of Node.js.  ---------  Co-authored-by: Sebastian ""Sebbie"" Silbermann <silbermann.sebastian@gmail.com>",840,76,916
facebook/react,1ae0a845bde5b95dfc319cadf366cb7b3fb1ca92,Sebastian Markbåge,2025-06-03T15:30:17Z,"Use underscore instead of « » for useId algorithm (#33422)  Alternative to #33421. The difference is that this also adds an underscore between the ""R"" and the ID.  The reason we wanted to use special characters is because we use the full spectrum of A-Z 0-9 in our ID generation so we can basically collide with any common word (or anyone using a similar algorithm, base64 or even base16). It's a little less likely that someone would put `_R_` specifically unless you generate like two IDs separated by underscore.   ![9w2ogt](https://github.com/user-attachments/assets/21b2d2ac-1a3a-4657-ba0b-1616e49dfdee)",85,96,181
facebook/react,2b4064eb9b40f65d20a03ce93b246ad762d562e6,Jorge Cabiedes,2025-06-03T04:42:34Z,[mcp] Add MCP tool to print out the component tree of the currently open React App (#33305)  ## Summary  This tool leverages DevTools to get the component tree from the currently open React App. This gives realtime information to agents about the state of the app.  ## How did you test this change?  Tested integration with Claude Desktop,171,0,171
facebook/react,3531b2672955285c0a59f84be06ac92b0d987a3e,Ricky,2025-06-03T04:00:28Z,[scripts] Switch back to flow parser for prettier (#33414)  Prettier 3.3 (which we're on) should support modern flow features according to https://prettier.io/blog/2024/06/01/3.3.0,8,33,41
facebook/react,4a1f29079ccc61659e026bbcf205bc8d53780927,"Sebastian ""Sebbie"" Silbermann",2025-06-02T17:27:49Z,[Fizz] Add Owner Stacks when render is aborted (#32735),81,1,82
facebook/react,526dd340b3e77193846fe5eed02b9bb89d7c2d15,mofeiZ,2025-06-02T15:43:45Z,[compiler][patch] Emit unary expressions instead of negative numbers (#33383)  This is a babel bug + edge case.  Babel compact mode produces invalid JavaScript (i.e. parse error) when given a `NumericLiteral` with a negative value.  See https://codesandbox.io/p/devbox/5d47fr for repro.,83,2,85
facebook/react,ee76351917106c6146745432a52e9a54a41ee181,Wesley LeMahieu,2025-05-30T23:31:16Z,"fix typo in compiler validation filename (#33345)  ## Summary  While investigating the root cause of #33208, I noticed a clear typo for one of the validation files.  ## How did you test this change?  Inside `/react/compiler/packages/babel-plugin-react-compiler` I ran the test script successfully:  <img width=""415"" alt=""Screenshot at May 22 16-43-06"" src=""https://github.com/user-attachments/assets/3fe8c5e1-37ce-4a31-b35e-7e323e57cd9d"" />",1,1,2
facebook/react,8b55eb4e724271206bd5dec7dba0a35aedc74493,Pieter De Baets,2025-05-30T16:17:59Z,"Cleanup props diffing experiments (#33381)  ## Summary  We completed testing on these internally, so can cleanup the separate fast and slow paths and remove the `enableShallowPropDiffing` flag which we're not pursuing.  ## How did you test this change?  ``` yarn test ReactNativeAttributePayloadFabric ```",11,85,96
facebook/react,14094f80cbf52cad4024211080d8491f3334ef61,Mateusz Burzyński,2025-05-29T15:17:10Z,Allow `nonce` to be used on hoistable styles (#32461)  fixes https://github.com/facebook/react/issues/32449  This is my first time touching this code. There are multiple systems in place here and I wouldn't be surprised to learn that this has to be handled in some other areas too. I have found some other style-related code areas but I had no time yet to double-check them.  cc @gnoff,398,30,428
facebook/react,5717f1933f2e8b10406fde1043c3047cbfbddc82,"Sebastian ""Sebbie"" Silbermann",2025-05-28T17:46:12Z,[react-dom] Enforce small gap between completed navigation and default Transition indicator (#33354),45,2,47
facebook/react,b07717d857422af5fb1c2ee0930e5a2a62df2b0e,Ricky,2025-05-28T14:31:09Z,[devtools] upgrade json5 (#33358),2,2,4
facebook/react,283f87f083f285c060582e1096cebed794d4b748,Jan Kassens,2025-05-27T21:17:45Z,"Revert ""enableViewTransition in www"" (#33362)  We need to do some more testing here.  Reverts facebook/react#33357",3,2,5
facebook/react,f9ae0a4c2edc9ad93507b550f2aeb60119955336,mofeiZ,2025-05-27T16:02:29Z,[compiler][gating] Custom opt out directives (experimental option) (#33328)  Adding an experimental / unstable compiler config to enable custom opt-out directives,104,21,125
facebook/react,f702620cea32f59a101d4f60fbff7a7495df76f7,Jan Kassens,2025-05-27T15:23:27Z,[fb-www] ship enableViewTransition (#33357),2,3,5
facebook/react,c0464aedb16b1c970d717651bba8d1c66c578729,Sebastian Markbåge,2025-05-23T17:26:02Z,"[Fizz] Block on Suspensey Fonts during reveal (#33342)  This is the same technique we do for the client except we don't check whether this is newly created font loading to keep code small.  Unfortunately, we can't use this technique for Suspensey images. They'll need to block before we call `startViewTransition` in a separate refactor. This is due to a bug in Chrome where `img.decode()` doesn't resolve until `startViewTransition` does.",15,2,17
facebook/react,6a1dfe37776e5a41f4c1e07c33cf1f26c4a82979,Sebastian Markbåge,2025-05-23T17:25:13Z,"Disable moveBefore experiment (#33348)  There seems to be some bugs still to work out in Chrome. See #33187.  Additionally, since you can't really rely on this function existing across browsers, it's hard to depend on its behavior anyway. In fact, you now have a source of inconsistent behaviors across browsers to deal with.  Ideally it would also be more widely spread in fake DOM implementations like JSDOM so that we can use it unconditionally. #33177.  We still want to enable this since it's a great feature but maybe not until it's more widely available cross-browsers with fewer bugs.",1,1,2
facebook/react,99efc627a5a8cb56f50cfffee544c86c49572b6f,Jordan Brown,2025-05-23T14:09:41Z,"[eslint] Add an option to require dependencies on effect hooks (#33344)  Summary:  To prepare for automatic effect dependencies, some codebases may want to codemod existing useEffect calls with no deps to include an explicit undefined second argument in order to preserve the ""run on every render"" behavior. In sufficiently large codebases, this may require a temporary enforcement period where all effects provide an explicit dependencies argument.  Outside of migration, relying on a component to render can lead to real bugs, especially when working with memoization.",32,0,32
facebook/react,bfaeb4a46175fa0f4edf2eba58349d5029e5e86e,0xFango,2025-05-23T02:02:39Z,"Fix incorrect use of NoLanes in executionContext check (#33170)  ## Summary  This PR fixes a likely incorrect condition in the `scheduleUpdateOnFiber` function inside `ReactFiberWorkLoop.js`.  Previously, the code checked:  ```js (executionContext & RenderContext) !== NoLanes ````  However, `NoLanes` is part of the lane priority system, not the execution context flags. The intent here seems to be to detect whether the current execution context includes `RenderContext`, which should be compared against `NoContext`, not `NoLanes`.  This fix replaces `NoLanes` with `NoContext` for semantic correctness and consistency with other checks throughout the codebase.  **Fixes [[#33169](https://github.com/facebook/react/issues/33169)](https://github.com/facebook/react/issues/33169)**  ---  ## How did you test this change?  I ran the following commands to validate correctness and ensure nothing was broken:  * `yarn lint` * `yarn linc` * `yarn test` * `yarn test --prod` * `yarn flow` * `yarn prettier`  All checks passed. Since this is a minor internal logic fix and doesn't change public behavior or APIs, no additional tests are necessary at this time.",1,1,2
facebook/react,3e9db65fc3341148a5248b3ffc6bc68c0640fd3f,Christoph Nakazawa,2025-05-22T20:18:23Z,"Fix typo in error message. (#33313)  ## Summary  I am writing code that isn't so good, so I saw this error message many times. It appears to have a typo. This PR fixes the typo.  ## How did you test this change?  Ran the tests",5,5,10
facebook/react,0d072884f9201f645ae298936f2933970b73bec4,mofeiZ,2025-05-22T20:14:49Z,"[compiler] Inferred effect dependencies now include optional chains (#33326)  Inferred effect dependencies now include optional chains.  This is a temporary solution while https://github.com/facebook/react/pull/32099 and its followups are worked on. Ideally, we should model reactive scope dependencies in the IR similarly to `ComputeIR` -- dependencies should be hoisted and all references rewritten to use the hoisted dependencies.  ` --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33326). * __->__ #33326 * #33325 * #32286",762,115,877
facebook/react,abf9fd559d584278c1c5f5464e35290651cf82bc,mofeiZ,2025-05-22T20:14:05Z,"[compiler] Add reactive flag on scope dependencies (#33325)  When collecting scope dependencies, mark each dependency with `reactive: true | false`. This prepares for later PRs https://github.com/facebook/react/pull/33326 and https://github.com/facebook/react/pull/32099 which rewrite scope dependencies into instructions.  Note that some reactive objects may have non-reactive properties, but we do not currently track this.  Technically, state[0] is reactive and state[1] is not. Currently, both would be marked as reactive. ```js const state = useState(); ``` --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33325). * #33326 * __->__ #33325 * #32286",109,19,128
facebook/react,13f20044f3a5a9433eb4c6ef4c6577b8f0d13350,mofeiZ,2025-05-22T20:13:50Z,[compiler] Prepare HIRBuilder to be used by later passes (#32286)  --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/32286). * #33326 * #33325 * __->__ #32286,34,25,59
facebook/react,8ce15b0f56a066ece465963ca1370e46113bb868,Sebastian Markbåge,2025-05-22T14:40:28Z,[Fizz] Apply View Transition Name and Class to SSR:ed View Transitions (#33332)  Stacked on #33330.  This walks the element tree to activate the various classes under different scenarios. There are some edge case things that are a little different since we can't express every scenario without virtual nodes.  The main thing that's still missing though is avoiding animating updates if it can be contained to a layout or enter/exit/share if they're out of the viewport. I.e. layout stuff.,204,19,223
facebook/react,91ac1fea1aacf80c9eb2815956e230921b55808c,Sebastian Markbåge,2025-05-22T14:25:13Z,[Fizz] Pass batch as argument to revealCompletedBoundaries (#33330)  Follow up to #33293.  This solves a race condition when boundaries are added to the batch after the `startViewTransition` call.  This doesn't matter yet but it will once we start assigning names before the `startViewTransition` call.  A possible alternative solution might be to ensure the names are added synchronously in the event that adds to the batch. It's possible to keep adding to a batch until the snapshot has happened.,18,10,28
facebook/react,08064ea6713ff55730c5d4f50b733891ebe0e875,Sebastian Markbåge,2025-05-22T14:21:28Z,[Fizz] Make ViewTransition enter/exit/share null the same as none (#33331)  I believe that these mean the same thing. We don't have to emit the attribute if it's `none` for these cases because if there is no matching scenario we won't apply the animation in this case.  The only case where we have to emit `none` in the attribute is for `vt-update` because those can block updates from propagating upwards.,11,17,28
facebook/react,99781d605b6a6fd332bba654ac0c328e41df888c,Sebastian Markbåge,2025-05-22T14:20:13Z,[Fizz] Track boundaries in future rows as postponed (#33329)  Follow up to #33321.  We can mark boundaries that were blocked in the prerender as postponed but without anything to replayed inside them. That way they're not emitted in the prerender but is unblocked when replayed.  Technically this does some unnecessary replaying of the path to the otherwise already completed boundary but it simplifies our model by just marking the boundary as needing replaying.,87,48,135
facebook/react,459a2c4298187cb0ee45605e2575ff35f4a81183,mofeiZ,2025-05-21T21:23:29Z,"[compiler][gating] Experimental directive based gating (#33149)  Adds `dynamicGating` as an experimental option for testing rollout DX at Meta. If specified, this enables dynamic gating which matches `use memo if(...)` directives.  #### Example usage Input file ```js // @dynamicGating:{""source"":""myModule""} export function MyComponent() {   'use memo if(isEnabled)';    return <div>...</div>; } ``` Compiler output ```js import {isEnabled} from 'myModule'; export const MyComponent = isEnabled()   ? <optimized version>   : <original version>; ``` --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33149). * __->__ #33149 * #33148",813,22,835
facebook/react,1c43d0aed74de4aae210ba7081b60f944df31954,Sebastian Markbåge,2025-05-21T20:13:54Z,"Unify serverAct helpers (#33327)  This uses the richer `serverAct` helper that we already use in other tests.  This avoids using the `Scheduler`. We don't use that package on the server so it doesn't make sense to simulate going through it. Additionally, we really should be getting rid of it on the client too to favor `postTask` polyfills.",94,255,349
facebook/react,1835b3f7d9c0541259a8812c5dfaf3d77f0721eb,Jack Pope,2025-05-21T19:47:47Z,"New children notify fragment instances in Fabric (#33093)  When a new child of a fragment instance is inserted, we need to notify the instance to keep any relevant tracking up to date. For example, we automatically observe the new child with any active IntersectionObserver.  For mutable renderers (DOM), we reuse the existing traversal in `commitPlacement` that does the insertions for HostComponents. Immutable renderers (Fabric) exit this path before the traversal though, so currently we can't notify the fragment instances.  Here I've created a separate traversal in `commitPlacement`, specifically for immutable renders when `enableFragmentRefs` is on.",109,26,135
facebook/react,f4041aa388b7eeba94a26f6c273e9f4c18e2d2b3,Sebastian Markbåge,2025-05-21T19:31:22Z,"[Fizz] Unblock SuspenseList when prerendering (#33321)  There's an interesting case when a SuspenseList is partially prerendered but some of the completed boundaries are blocked by rows to be resumed.  This handles it but just unblocking the future rows to avoid stalling.  However, the correct semantics will need special handling in the postponed state.",90,0,90
facebook/react,3710c4d4f9ffb6aa07e291b822e4ec7d69ed5a32,Jack Pope,2025-05-21T17:57:35Z,"Prevent errors from comment node roots with enableViewTransition (#33205)  We have many cases internally where the `containerInstance` resolves to a comment node. `restoreRootViewTransitionName` is called when `enableViewTransition` is on, even without introducing a `<ViewTransition />`. So that means it can crash pages because `containerInstance.style` is `undefined` just by turning on the flag.  This skips cancel/restore of root view transition name if a comment node is the root.",36,4,40
facebook/react,2388481283640d034fd6b4edfca4f11e67953673,Sebastian Markbåge,2025-05-21T01:08:47Z,[Fizz] Set keyPath for SuspenseList (#33320)  I missed setting the `keyPath` because the `renderChildrenArray` that this is forked from doesn't need to set a path but since this is rendered from the `SuspenseList` element it needs it.,4,3,7
facebook/react,9c7b10e22ea4c184c0465df15705f17ba36b115a,Sebastian Markbåge,2025-05-21T00:31:16Z,[Fizz] Clean up row that was blocked by an aborted boundary (#33318)  Fixes a bug that we caused us to hang after an abort because we didn't manage the ref count correctly.,160,13,173
facebook/react,50389e179273558d0919d45bc5db99a21b258b03,Sebastian Markbåge,2025-05-20T18:48:51Z,"[Fizz] Hoist hoistables to each row and transfer the dependencies to future rows (#33312)  Stacked on #33311.  When a row contains Suspense boundaries that themselves depend on CSS, they will not resolve until the CSS has loaded on the client. We need future rows in a list to be blocked until this happens. We could do something in the runtime but a simpler approach is to just add those CSS dependencies to all those boundaries as well.  To do this, we first hoist the HoistableState from a completed boundary onto its parent row. Then when the row finishes do we hoist it onto the next row and onto any boundaries within that row.",210,5,215
facebook/react,99aa685cefc3c828d4523da04d7830c1e494a6bd,Sebastian Markbåge,2025-05-20T18:42:05Z,"[Fizz] Support SuspenseList revealOrder=""together"" (#33311)  Stacked on #33308.  For ""together"" mode, we can be a self-blocking row that adds all its boundaries to the blocked set, but there's no parent row that unblocks it.  A particular quirk of this mode is that it's not enough to just unblock them all on the server together. Because if one boundary downloads all its html and then issues a complete instruction it'll appear before the others while streaming in. What we actually want is to reveal them all in a single batch.  This implementation takes a short cut by unblocking the rows in `flushPartialBoundary`. That ensures that all the segments of every boundary has a chance to flush before we start emitting any of the complete boundary instructions. Once the last one unblocks, all the complete boundary instructions are queued. Ideally this would be a single `<script>` tag so that they can't be split up even if we get a chunk containing some of them.  ~A downside of this approach is that we always outline these boundaries. We could inline them if they all complete before the parent flushes. E.g. by checking if the row is blocked only by its own boundaries and if all the boundaries would fit without getting outlined, then we can inline them all at once.~ I went ahead and did this because it solves an issue with `renderToString` where it doesn't support the script runtime so it can only handle this if inlined.",404,3,407
facebook/react,d38c7e10d3625c550744ce36c623a73c15c2b5d8,Jan Kassens,2025-05-20T16:20:51Z,"Remove leftover Rust script (#33314)  For now we removed Rust from the codebase, remove this leftover script.  Also remove some dupes and Rust related files from `.gitignore`.",0,26,26
facebook/react,c4676e72a630f3e93634c2b004b3be07b17a79c8,Sebastian Markbåge,2025-05-20T13:39:46Z,"[Fizz] Handle nested SuspenseList (#33308)  Follow up to #33306.  If we're nested inside a SuspenseList and we have a row, then we can point our last row to block the parent row and unblock the parent when the last child unblocks.",85,4,89
facebook/react,4c6967be290fc31182c61cfdac19915fdb16aa60,Sebastian Markbåge,2025-05-20T13:39:25Z,"[Fiber] Support AsyncIterable children in SuspenseList (#33299)  We support AsyncIterable (more so when it's a cached form like in coming from Flight) as children.  This fixes some warnings and bugs when passed to SuspenseList.  Ideally SuspenseList with `tail=""hidden""` should support unblocking before the full result has resolved but that's an optimization on top. We also might want to change semantics for this for `revealOrder=""backwards""` so it becomes possible to stream items in reverse order.",306,77,383
facebook/react,c6c2a52ad8fb1894b03a3bb618eb57e5deca5aa0,Joseph Savona,2025-05-19T22:29:58Z,"[compiler] Fix error message for custom hooks (#33310)  We were printing ""Custom"" instead of ""hook"".",13,13,26
facebook/react,5dc1b212c330b6f456789f8d58e0f87abefbb86c,Sebastian Markbåge,2025-05-19T19:16:42Z,"[Fizz] Support basic SuspenseList forwards/backwards revealOrder (#33306)  Basically we track a `SuspenseListRow` on the task. These keep track of ""pending tasks"" that block the row. A row is blocked by:  - First itself completing rendering. - A previous row completing. - Any tasks inside the row and before the Suspense boundary inside the row. This is mainly because we don't yet know if we'll discover more SuspenseBoundaries. - Previous row's SuspenseBoundaries completing.  If a boundary might get outlined, then we can't consider it completed until we have written it because it determined whether other future boundaries in the row can finish.  This is just handling basic semantics. Features not supported yet that need follow ups later:  - CSS dependencies of previous rows should be added as dependencies of future row's suspense boundary. Because otherwise if the client is blocked on CSS then a previous row could be blocked but the server doesn't know it. - I need a second pass on nested SuspenseList semantics. - `revealOrder=""together""` - `tail=""hidden""`/`tail=""collapsed""`. This needs some new runtime semantics to the Fizz runtime and to allow the hydration to handle missing rows in the HTML. This should also be future compatible with AsyncIterable where we don't know how many rows upfront. - Need to double check resuming semantics.  ---------  Co-authored-by: Sebastian ""Sebbie"" Silbermann <silbermann.sebastian@gmail.com>",792,31,823
facebook/react,a3abf5f2f835ad0c61e2325f5cbac2d1d9045517,Jan Kassens,2025-05-19T19:08:30Z,[eslint-plugin-react-hooks] add experimental_autoDependenciesHooks option (#33294),157,10,167
facebook/react,462d08f9ba41d48ab36bf405235c1c22023603dc,Sebastian Markbåge,2025-05-18T00:00:56Z,Move SuspenseListProps into a shared/ReactTypes (#33298)  So they can be shared by server. Incorporates the types from definitely typed too.,29,7,36
facebook/react,6060367ef8a7a5bac12e0f830367bb13626db83a,Sebastian Markbåge,2025-05-17T22:18:24Z,"[Fizz] Wrap revealCompletedBoundaries in a ViewTransitions aware version (#33293)  When needed.  For the external runtime we always include this wrapper.  For others, we only include it if we have an ViewTransitions affecting. If we discover the ViewTransitions late, then we can upgrade an already emitted instruction.  This doesn't yet do anything useful with it, that's coming in a follow up. This is just the mechanism for how it gets installed.",259,109,368
facebook/react,c250b7d980864be49facf2306f06455e7f9e305d,Sebastian Markbåge,2025-05-16T18:53:40Z,"[Fizz] Should be considered complete inside onShellReady callback (#33295)  We decremented `allPendingTasks` after invoking `onShellReady`. Which means that in that scope it wasn't considered fully complete.  Since the pattern for flushing in Node.js is to start piping in `onShellReady` and that's how you can get sync behavior, this led us to think that we had more work left to do. For example we emitted the `writeShellTimeInstruction` in this scenario before.",16,1,17
facebook/react,4448b18760d867f9e009e810571e7a3b8930bb19,Jan Kassens,2025-05-15T16:51:18Z,[eslint-plugin-react-hooks] fix exhaustive deps lint rule with component syntax (#33182),65,2,67
facebook/react,4a45ba92c4097a97333c04b5516ba2d5c81af716,Ricky,2025-05-15T16:12:51Z,"[sync] Fix noop for xplat (#33214)  Noop detection for xplat syncs broke because `eslint-plugin-react-hooks` uses versions like:  - `0.0.0-experimental-d85f86cf-20250514`  But xplat expects them to be of the form:  - `19.2.0-native-fb-63d664b2-20250514`  This PR fixes the noop by ignoring `eslint-plugin-react-hooks/package.json` changes. This means we won't create a sync if only that package.json changes, but that should be rare and we can follow up with better detection if needed.  [Example failed action](https://github.com/facebook/react/actions/runs/15032346805/job/42247414406):  <img width=""1031"" alt=""Screenshot 2025-05-15 at 11 31 17 AM"" src=""https://github.com/user-attachments/assets/d902079c-1afe-4e18-af1d-25e60e28929e"" />  I believe the regression was caused by https://github.com/facebook/react/pull/33104",2,2,4
facebook/react,08cb2d7ee732f35ef1935c75c081754bd81d60b9,lauren,2025-05-15T15:49:56Z,"[ci] Log author_association (#33213)  For debugging purposes, log author_association",3,0,3
facebook/react,203df2c9409f580fd63eeacd4f80d70c2741bd4f,lauren,2025-05-15T14:34:11Z,[compiler] Update changelog for 19.1.0-rc.2 (#33207)  Update the changelog.,6,0,6
facebook/react,65b5aae010002ef88221cc4998711eaef6068006,Sebastian Markbåge,2025-05-15T05:04:10Z,"[Fizz] Add vt- prefix attributes to annotate <ViewTransition> in HTML (#33206)  Stacked on #33194 and #33200.  When Suspense boundaries reveal during streaming, the Fizz runtime will be responsible for animating the reveal if necessary (not in this PR). However, for the future runtime to know what to do it needs to know about the `<ViewTransition>` configuration to apply.  Ofc, these are virtual nodes that disappear from the HTML. We could model them as comments like we do with other virtual nodes like Suspense and Activity. However, that doesn't let us target them with querySelector and CSS (for no-JS transitions). We also don't have to model every ViewTransition since not every combination can happen using only the server runtime. So instead this collapses `<ViewTransition>` and applies the configuration to the inner DOM nodes.  ```js <ViewTransition name=""hi"">   <div />   <div /> </ViewTransition> ```  Becomes:  ```html <div vt-name=""hi"" vt-update=""auto""></div> <div vt-name=""hi_1"" vt-update=""auto""></div> ```  I use `vt-` prefix as opposed to `data-` to keep these virtual attributes away from user specific ones but we're effectively claiming this namespace.  There are four triggers `vt-update`, `vt-enter`, `vt-exit` and `vt-share`. The server resolves which ones might apply to this DOM node. The value represents the class name (after resolving view-transition-type mappings) or `""auto""` if no specific class name is needed but this is still a trigger.  The value can also be `""none""`. This is different from missing because for example an `vt-update=""none""` will block mutations inside it from triggering the boundary where as a missing `vt-update` would bubble up to be handled by a parent.  `vt-name` is technically only necessary when `vt-share` is specified to find a pair. However, since an explicit name can also be used to target specific CSS selectors, we include it even for other cases.  We want to exclude as many of these annotations as possible.  `vt-enter` can only affect the first DOM node inside a Suspense boundary's content since the reveal would cause it to enter but nothing deeper inside. Similarly `vt-exit` can only affect the first DOM node inside a fallback. So for every other case we can exclude them. (For future MPA ViewTransitions of the whole document it might also be something we annotate to children inside the `<body>` as well.) Ideally we'd only include `vt-enter` for Suspense boundaries that actually flushed a fallback but since we prepare all that content earlier it's hard to know.  `vt-share` can be anywhere inside an fallback or content. Technically we don't have to include it outside the root most Suspense boundary or for boundaries that are inlined into the root shell. However, this is tricky to detect. It would also not be correct for future MPA ViewTransitions because in that case the shared scenario can affect anything in the two documents so it needs to be in every node everywhere which is effectively what we do. If a `share` class is specified but it has no explicit name, we can exclude it since it can't match anything.  `vt-update` is only necessary if something below or a sibling might update like a Suspense boundary. However, since we don't know when rendering a segment if it'll later asynchronously add a Suspense boundary later we have to assume that anywhere might have a child. So these are always included. We collapse to use the inner most one when directly nested though since that's the one that ends up winning.  There are some weird edge cases that can't be fully modeled by the lack of virtual nodes.",797,60,857
facebook/react,3f67d0857efc3ab21b9d30851f5a8451471166ab,Sebastian Markbåge,2025-05-15T04:06:06Z,[Fizz] Track whether we're in a fallback on FormatContext (#33194)  Removes the `isFallback` flag on Tasks and tracks it on the formatContext instead.  Less memory and avoids passing and tracking extra arguments to all the pushStartInstance branches that doesn't need it.  We'll need to be able to track more Suspense related contexts on this for View Transitions anyway.,88,86,174
facebook/react,96eb84e493c4ff2c280990659057164c0f16bbb8,Sebastian Markbåge,2025-05-14T21:52:41Z,"Claim the useId name space for every auto named ViewTransition (#33200)  This is a partial revert of #33094. It's true that we don't need the server and client ViewTransition names to line up. However the server does need to be able to generate deterministic names for itself. The cheapest way to do that is using the useId algorithm. When it's used by the server, the client needs to also materialize an ID even if it doesn't use it.",23,1,24
facebook/react,63d664b220b1587da0f3b4ced895456f3d8320da,Sebastian Markbåge,2025-05-14T21:50:56Z,"Don't consider Portals animating unless they're wrapped in a ViewTransition (#33191)  And that doesn't disable with `update=""none""`.  The principle here is that we want the content of a Portal to animate if other things are animating with it but if other things aren't animating then we don't.",14,3,17
facebook/react,d85f86cf017151bcf5908d593c3899d876656a01,Jan Kassens,2025-05-14T15:27:36Z,Delete stray file (#33199)  Not sure where this was coming from.,0,47,47
facebook/react,3a5b326d8180f005a10e34a07ded6d5632efe337,Sebastian Markbåge,2025-05-13T20:10:28Z,"[Fiber] Trigger default indicator for isomorphic async actions with no root associated (#33190)  Stacked on #33160, #33162, #33186 and #33188.  We have a special case that's awkward for default indicators. When you start a new async Transition from `React.startTransition` then there's not yet any associated root with the Transition because you haven't necessarily `setState` on anything yet until the promise resolves. That's what `entangleAsyncAction` handles by creating a lane that everything entangles with until all async actions are done.  If there are no sync updates before the end of the event, we should trigger a default indicator until either the async action completes without update or if it gets entangled with some roots we should keep it going until those roots are done.",274,20,294
facebook/react,59440424d05360cca32ca6f46ae33661f70d43e2,Sebastian Markbåge,2025-05-13T20:00:38Z,"Implement Navigation API backed default indicator for DOM renderer (#33162)  Stacked on #33160.  By default, if `onDefaultTransitionIndicator` is not overridden, this will trigger a fake Navigation event using the Navigation API. This is intercepted to create an on-going navigation until we complete the Transition. Basically each default Transition is simulated as a Navigation.  This triggers the native browser loading state (in Chrome at least). So now by default the browser spinner spins during a Transition if no other loading state is provided. Firefox and Safari hasn't shipped Navigation API yet and even in the flag Safari has, it doesn't actually trigger the native loading state.  To ensures that you can still use other Navigations concurrently, we don't start our fake Navigation if there's one on-going already. Similarly if our fake Navigation gets interrupted by another. We wait for on-going ones to finish and then start a new fake one if we're supposed to be still pending.  There might be other routers on the page that might listen to intercept Navigation Events. Typically you'd expect them not to trigger a refetch when navigating to the same state. However, if they want to detect this we provide the `""react-transition""` string in the `info` field for this purpose.",240,6,246
facebook/react,b480865db0babfcad602a1a1909775069b5779f9,Sebastian Markbåge,2025-05-13T19:52:44Z,"[Fiber] Always flush Default priority in the microtask if a Transition was scheduled (#33186)  Stacked on #33160.  The purpose of this is to avoid calling `onDefaultTransitionIndicator` when a Default priority update acts as the loading indicator, but still call it when unrelated Default updates happens nearby.  When we schedule Default priority work that gets batched with other events in the same frame more or less. This helps optimize by doing less work. However, that batching means that we can't separate work from one setState from another. If we would consider all Default priority work in a frame when determining whether to show the default we might never show it in cases like when you have a recurring timer updating something.  This instead flushes the Default priority work eagerly along with the sync work at the end of the event, if this event scheduled any Transition work. This is then used to determine if the default indicator needs to be shown.",9,4,13
facebook/react,62d3f36ea79fc0a10b514d4bbcc4ba3f21b3206e,Sebastian Markbåge,2025-05-13T19:45:11Z,"[Fiber] Trigger default transition indicator if needed (#33160)  Stacked on #33159.  This implements `onDefaultTransitionIndicator`.  The sequence is:  1) In `markRootUpdated` we schedule Transition updates as needing `indicatorLanes` on the root. This tracks the lanes that currently need an indicator to either start or remain going until this lane commits. 2) Track mutations during any commit. We use the same hook that view transitions use here but instead of tracking it just per view transition scope, we also track a global boolean for the whole root. 3) If a sync/default commit had any mutations, then we clear the indicator lane for the `currentEventTransitionLane`. This requires that the lane is still active while we do these commits. See #33159. In other words, a sync update gets associated with the current transition and it is assumed to be rendering the loading state for that corresponding transition so we don't need a default indicator for this lane. 4) At the end of `processRootScheduleInMicrotask`, right before we're about to enter a new ""event transition lane"" scope, it is no longer possible to render any more loading states for the current transition lane. That's when we invoke `onDefaultTransitionIndicator` for any roots that have new indicator lanes. 5) When we commit, we remove the finished lanes from `indicatorLanes` and once that reaches zero again, then we can clean up the default indicator. This approach means that you can start multiple different transitions while an indicator is still going but it won't stop/restart each time. Instead, it'll wait until all are done before stopping.  Follow ups:  - [x] Default updates are currently not enough to cancel because those aren't flush in the same microtask. That's unfortunate. #33186 - [x] Handle async actions before the setState. Since these don't necessarily have a root this is tricky. #33190 - [x] Disable for `useDeferredValue`. ~Since it also goes through `markRootUpdated` and schedules a Transition lane it'll get a default indicator even though it probably shouldn't have one.~ EDIT: Turns out this just works because it doesn't go through `markRootUpdated` when work is left behind. - [x] Implement built-in DOM version by default. #33162",490,6,496
facebook/react,0cac32d60dd4482b27fe8a54dffbabceb22c6272,Sebastian Markbåge,2025-05-13T19:20:59Z,"[Fiber] Stash the entangled async action lane on currentEventTransitionLane (#33188)  When we're entangled with an async action lane we use that lane instead of the currentEventTransitionLane. Conversely, if we start a new async action lane we reuse the currentEventTransitionLane.  So they're basically supposed to be in sync but they're not if you resolve the async action and then schedule new stuff in the same event. Then you end up with two transitions in the same event with different lanes.  By stashing it like this we fix that but it also gives us an opportunity to check just the currentEventTransitionLane to see if this event scheduled any regular Transition updates or Async Transitions.",11,10,21
facebook/react,676f0879f315130309262ff3532707029f0288bb,Sebastian Markbåge,2025-05-13T19:18:02Z,Reset currentEventTransitionLane after flushing sync work (#33159)  This keeps track of the transition lane allocated for this event. I want to be able to use the current one within sync work flushing to know which lane needs its loading indicator cleared.  It's also a bit weird that transition work scheduled inside sync updates in the same event aren't entangled with other transitions in that event when `flushSync` is.  Therefore this moves it to reset after flushing.  It should have no impact. Just splitting it out into a separate PR for an abundance of caution.  The only thing this might affect would be if the React internals throws and it doesn't reset after. But really it doesn't really have to reset and they're all entangled anyway.,3,1,4
facebook/react,997c7bc930304142b3af37bcb21599181124aeb4,Sebastian Markbåge,2025-05-13T16:39:10Z,"[DevTools] Get source location from structured callsites in prepareStackTrace (#33143)  When we get the source location for ""View source for this element"" we should be using the enclosing function of the callsite of the child. So that we don't just point to some random line within the component.  This is similar to the technique in #33136.  This technique is now really better than the fake throw technique, when available. So I now favor the owner technique. The only problem it's only available in DEV and only if it has a child that's owned (and not filtered).  We could implement this same technique for the error that's thrown in the fake throwing solution. However, we really shouldn't need that at all because for client components we should be able to call `inspect(fn)` at least in Chrome which is even better.",90,15,105
facebook/react,b94603b95504130aec72f61e02d7b66d48f33653,Sebastian Markbåge,2025-05-13T14:17:53Z,"[Fizz] Gate rel=""expect"" behind enableFizzBlockingRender (#33183)  Enabled in experimental channel.  We know this is critical semantics to enforce at the HTML level since if you don't then you can't add explicit boundaries after the fact. However, this might have to go in a major release to allow for upgrading.",194,55,249
facebook/react,2bcf06b69254cad6f7e702bf7d65c4f30478668c,Jenny Steele,2025-05-13T01:16:15Z,[ReactFlightWebpackPlugin] Add support for .mjs file extension (#33028)  ## Summary Our builds generate files with a `.mjs` file extension. These are currently filtered out by `ReactFlightWebpackPlugin` so I am updating it to support this file extension.  This fixes https://github.com/facebook/react/issues/33155  ## How did you test this change? I built the plugin with this change and used `yalc` to test it in my project. I confirmed the expected files now show up in `react-client-manifest.json`,8,2,10
facebook/react,5d04d73274a884ed53106677d56dd837ae668c45,Samuel Susla,2025-05-12T16:39:20Z,"Add eager alternate.stateNode cleanup (#33161)  This is a fix for a problem where React retains shadow nodes longer than it needs to. The behaviour is shown in React Native test: https://github.com/facebook/react-native/blob/main/packages/react-native/src/private/__tests__/utilities/__tests__/ShadowNodeReferenceCounter-itest.js#L169  # Problem When React commits a new shadow tree, old shadow nodes are stored inside `fiber.alternate.stateNode`. This is not cleared up until React clones the node again. This may be problematic if mutation deletes a subtree, in that case `fiber.alternate.stateNode` will retain entire subtree until next update. In case of image nodes, this means retaining entire images.  So when React goes from revision A: `<View><View /></View>` to revision B: `<View />`, `fiber.alternate.stateNode` will be pointing to Shadow Node that represents revision A..   ![image](https://github.com/user-attachments/assets/076b677e-d152-4763-8c9d-4f923212b424)   # Fix To fix this, this PR adds a new feature flag `enableEagerAlternateStateNodeCleanup`. When enabled, `alternate.stateNode` is proactively pointed towards finishedWork's stateNode, releasing resources sooner.  I have verified this fixes the issue [demonstrated by React Native tests](https://github.com/facebook/react-native/blob/main/packages/react-native/src/private/__tests__/utilities/__tests__/ShadowNodeReferenceCounter-itest.js#L169). All existing React tests pass when the flag is enabled.",25,0,25
facebook/react,3820740a7fbfc3b27a5127b43bdad44382ff3ce0,mofeiZ,2025-05-09T17:37:49Z,[compiler][entrypoint] Fix edgecases for noEmit and opt-outs (#33148)  Title --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33148). * #33149 * __->__ #33148,39,35,74
facebook/react,5069e18060e00d7c07b2b04ebc8a3fa21e2d810a,mofeiZ,2025-05-09T17:23:08Z,"[compiler][be] Make program traversal more readable (#33147)  React Compiler's program traversal logic is pretty lengthy and complex as we've added a lot of features piecemeal. `compileProgram` is 300+ lines long and has confusing control flow (defining helpers inline, invoking visitors, mutating-asts-while-iterating, mutating global `ALREADY_COMPILED` state).  - Moved more stuff to `ProgramContext` - Separated `compileProgram` into a bunch of helpers  Tested by syncing this stack to a Meta codebase and observing no compilation output changes (D74487851, P1806855669, P1806855379) --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33147). * #33149 * #33148 * __->__ #33147",521,250,771
facebook/react,21fdf308a1a01af69c28c00a70086aa1bd4c2411,Sebastian Markbåge,2025-05-09T01:33:18Z,Use a shared noop function from shared/noop (#33154)  Stacked on #33150.  We use `noop` functions in a lot of places as place holders. I don't think there's any real optimizations we get from having separate instances. This moves them to use a common instance in `shared/noop`.,48,45,93
facebook/react,4ca97e4891b6a664b4c3a183f16b81139655ff57,Jack Pope,2025-05-09T00:49:23Z,Clean up enableSiblingPrerendering flag (#32319),866,1178,2044
facebook/react,9b79292ae7c2980acb531f1dff3cf1ca2d2f40b7,Sebastian Markbåge,2025-05-09T00:42:50Z,Add plumbing for onDefaultTransitionIndicator (#33150)  This just adds the options at the root and wire it up to the root but it doesn't do anything yet.,92,4,96
facebook/react,ac06829246287751e6b74bd99cd1b39d1aeba06a,Niklas Mollenhauer,2025-05-08T16:24:22Z,"feat(compiler): Implement constant propagation for template literals  (#33139)  New take on #29716  ## Summary Template literals consisting entirely of constant values will be inlined to a string literal, effectively replacing the backticks with a double quote.  This is done primarily to make the resulting instruction a string literal, so it can be processed further in constant propatation. So this is now correctly simplified to `true`: ```js `` === """" // now true `a${1}` === ""a1"" // now true ```  If a template string literal can only partially be comptime-evaluated, it is not that useful for dead code elimination or further constant folding steps and thus, is left as-is in that case. Same is true if the literal contains an array, object, symbol or function.  ## How did you test this change?  See added tests.",268,9,277
facebook/react,38ef6550a88f7744f5dcd4a3de7af6f13a540be5,mofeiZ,2025-05-08T15:26:53Z,[compiler][playground][tests] Standardize more pragmas (#33146)  (Almost) all pragmas are now one of the following: - `@...TestOnly`: custom pragma for test fixtures - `@<configName>` | `@<configName>:true`: enables with either true or a default enabled value - `@<configName>:<json value>`,350,454,804
facebook/react,b629a865fb18b899d251bf5c3c5ca2580d222720,mofeiZ,2025-05-08T15:24:44Z,[compiler][be] Move test pragma to separate file (#33145)  `Environment.ts` is getting complex so let's separate test / playground parsing logic from it --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33145). * #33146 * __->__ #33145,211,199,410
facebook/react,fbe7bc21b9aa00afa230132b3f7eee6d2b5c94a7,mofeiZ,2025-05-08T15:18:16Z,[compiler][be] repro edge cases for noEmit and module opt-outs (#33144)  see test fixtures --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33144). * #33146 * #33145 * __->__ #33144,95,0,95
facebook/react,9518f1185621aecb99fd72385cdb137c6e8bd8fe,Dawid Małecki,2025-05-08T11:12:35Z,Root import types from react-native in ReactNativeTypes (#33063),34,27,61
facebook/react,557a64795c6b55e32a87c468c9069b05319d3b9b,Ruslan Lesiutin,2025-05-08T07:01:17Z,"React DevTools 6.1.1 -> 6.1.2 (#33142)  Patch release to mitigate https://github.com/facebook/react/issues/32659  Essentially just 6.1.1 with: * Restore all Transitions for Tree updates ([eps1lon](https://github.com/eps1lon) in [#33042](https://github.com/facebook/react/pull/33042)) * Restore ""double-click to view owners tree"" functionality ([eps1lon](https://github.com/eps1lon) in [#33039](https://github.com/facebook/react/pull/33039))",17,10,27
facebook/react,8a8df5dbdd57bf63d5156c1a9cba21ac6106b83d,Jack Pope,2025-05-07T18:00:59Z,"Add dispatchEvent to fragment instances (#32813)  `fragmentInstance.dispatchEvent(evt)` calls `element.dispatchEvent(evt)` on the fragment's host parent. This mimics bubbling if the `fragmentInstance` could receive an event itself.  If the parent is disconnected, there is a dev warning and no event is dispatched.",673,365,1038
facebook/react,946da518eb2d64d808f9204a72e05892d3005f3f,Niklas Mollenhauer,2025-05-07T17:15:11Z,"feat(compiler): implement constant folding for unary minus (#33140)  ## Summary `-constant` is represented as a `UnaryExpression` node that is currently not part of constant folding. If the operand is a constant number, the node is folded to `constant * -1`. This also coerces `-0` to `0`, resulting in `0 === -0` being folded to `true`.  ## How did you test this change? See attached tests",117,1,118
facebook/react,a437c99ff7a45025367571363653c2ad5db482a7,Sebastian Markbåge,2025-05-07T17:02:41Z,[Flight] Clarify that location field is a FunctionLocation not a CallSite (#33141)  Follow up to #33136.  This clarifies in the types where the conversion happens from a CallSite which we use to simulate getting the enclosing line/col to a FunctionLocation which doesn't represent a CallSite but actually just the function which only has an enclosing line/col.,23,10,33
facebook/react,4206fe49825787eda57a5d142640a63772ccbf2b,Jack Pope,2025-05-07T16:47:28Z,"Allow fragment refs to attempt focus/focusLast on nested host children (#33058)  This enables `focus` and `focusLast` methods on FragmentInstances to search nested host components, depth first. Attempts focus on each child and bails if one is successful. Previously, only the first level of host children would attempt focus.  Now if we have an example like  ``` component MenuItem() {   return (<div><a>{...}</a></div>) }  component Menu() {   return <Fragment>{items.map(i => <MenuItem i={i} />)}</Fragment> } ``` We can target focus on the first or last a tag, rather than checking each wrapping div and then noop.",88,23,111
facebook/react,4a702865dd0c5849c1b454091560c3ef26121611,Sebastian Markbåge,2025-05-07T16:34:55Z,"[Flight] Encode enclosing line/column numbers and use it to align the fake function (#33136)  Stacked on #33135.  This encodes the line/column of the enclosing function as part of the stack traces. When that information is available.  I adjusted the fake function code generation so that the beginning of the arrow function aligns with these as much as possible.  This ensures that when the browser tries to look up the line/column of the enclosing function, such as for getting the function name, it gets the right one. If we can't get the enclosing line/column, then we encode it at the beginning of the file. This is likely to get a miss in the source map identifiers, which means that the function name gets extracted from the runtime name instead which is better.  Another thing where this is used is the in the Performance Track. Ideally that would be fixed by https://issues.chromium.org/u/1/issues/415968771 but the enclosing information is useful for other things like the function name resolution anyway.  We can also use this for the ""View source for this element"" in React DevTools.",110,15,125
facebook/react,0ff1d13b8055c801d8b9b6779958c09fd0dc63e0,Sebastian Markbåge,2025-05-07T15:43:37Z,[Flight] Parse Stack Trace from Structured CallSite if available (#33135)  This is first step to include more enclosing line/column in the parsed data.  We install our own `prepareStackTrace` to collect structured callsite data and only fall back to parsing the string if it was already evaluated or if `prepareStackTrace` doesn't work in this environment.  We still mirror the default V8 format for encoding the function name part. A lot of this is covered by tests already.,139,16,155
facebook/react,53c9f81049b4440a02b5ed3edb128516821c0279,YongSeok Jang (장용석),2025-05-07T14:48:17Z,"[DevTools] Use Popover API for TraceUpdates highlighting (#32614)  ## Summary  When using React DevTools to highlight component updates, the highlights would sometimes appear behind elements that use the browser's [top-layer](https://developer.mozilla.org/en-US/docs/Glossary/Top_layer) (such as `<dialog>` elements or components using the Popover API). This made it difficult to see which components were updating when they were inside or behind top-layer elements.  This PR fixes the issue by using the Popover API to ensure that highlighting appears on top of all content, including elements in the top-layer. The implementation maintains backward compatibility with browsers that don't support the Popover API.  ## How did you test this change?  I tested this change in the following ways:  1. Manually tested in Chrome (which supports the Popover API) with: - Created a test application with React components inside `<dialog>` elements and custom elements using the Popover API - Verified that component highlighting appears above these elements when they update - Confirmed that highlighting displays correctly for nested components within top-layer elements  2. Verified backward compatibility: - Tested in browsers without Popover API support to ensure fallback behavior works correctly - Confirmed that no errors occur and highlighting still functions as before  3. Ran the React DevTools test suite:    - All tests pass successfully    - No regressions were introduced  [demo-page](https://devtools-toplayer-demo.vercel.app/) [demo-repo](https://github.com/yongsk0066/devtools-toplayer-demo)  ### AS-IS  https://github.com/user-attachments/assets/dc2e1281-969f-4f61-82c3-480153916969  ### TO-BE  https://github.com/user-attachments/assets/dd52ce35-816c-42f0-819b-0d5d0a8a21e5",124,3,127
facebook/react,e5a8de81e57181692d33ce916dfd6aa23638ec92,Jack Pope,2025-05-06T17:01:40Z,"Add compareDocumentPosition to fragment instances (#32722)  This adds `compareDocumentPosition(otherNode)` to fragment instances.  The semantics implemented are meant to match typical element positioning, with some fragment specifics. See the unit tests for all expectations.  - An element preceding a fragment is `Node.DOCUMENT_POSITION_PRECEDING` - An element after a fragment is `Node.DOCUMENT_POSITION_FOLLOWING` - An element containing the fragment is `Node.DOCUMENT_POSITION_PRECEDING` and `Node.DOCUMENT_POSITION_CONTAINING` - An element within the fragment is `Node.DOCUMENT_POSITION_CONTAINED_BY` - An element compared against an empty fragment will result in `Node.DOCUMENT_POSITION_DISCONNECTED` and `Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC`  Since we assume a fragment instances target children are DOM siblings and we want to compare the full fragment as a pseudo container, we can compare against the first target child outside of handling the special cases (empty fragments and contained elements).",1013,84,1097
facebook/react,7a2c7045aed222b1ece44a18db6326f2f10c89e3,Jorge Cabiedes,2025-05-06T15:50:40Z,[mcp] Add proper web-vitals metric collection (#33109)  Multiple things here: - Improve the mean calculation for metrics so we don't report 0 when web-vitals fail to be retrieved - improve ui chaos monkey to use puppeteer APIs since only those trigger INP/CLS metrics since we need emulated mouse clicks - Add logic to navigate to a temp page after render since some web-vitals metrics are only calculated when the page is backgrounded - Some readability improvements,130,64,194
facebook/react,845d93742fb090e7a35abea409a55e2a14613255,Sebastian Markbåge,2025-05-06T14:33:03Z,"Remove useId semantics from View Transition name generation (#33094)  Originally I thought it was important that SSR used the same View Transition name as the client so that the Fizz runtime could emit those names and then the client could pick up and take over. However, I no longer believe that approach is feasible. Instead, the names can be generated only during that particular animation.  Therefore we can simplify the auto name assignment to not have to consider the hydration.",15,64,79
facebook/react,54a50729cc47a884c2110d7c59dd5f850748e142,Sebastian Markbåge,2025-05-06T04:23:27Z,"[Fiber] Replay events between commits (#33130)  Stacked on #33129. Flagged behind `enableHydrationChangeEvent`.  If you type into a controlled input before hydration and something else rerenders like a setState in an effect, then the controlled input will reset to whatever React thought it was. Even with event replaying that this is stacked on, if the second render happens before event replaying has fired in a separate task.  We don't want to flush inside the commit phase because then things like flushSync in these events wouldn't work since they're inside the commit stack.  This flushes all event replaying between renders by flushing it at the end of `flushSpawned` work. We've already committed at that point and is about to either do subsequent renders or yield to event loop for passive effects which could have these events fired anyway. This just ensures that they've already happened by the time subsequent renders fire. This means that there's now a type of event that fire between sync render passes.",124,7,131
facebook/react,587cb8f8967866139bbfdbae3f519cb37e68a054,Sebastian Markbåge,2025-05-06T04:10:05Z,"[Fiber] Replay onChange Events if input/textarea/select has changed before hydration (#33129)  This fixes a long standing issue that controlled inputs gets out of sync with the browser state if it's changed before we hydrate.  This resolves the issue by replaying the change events (click, input and change) if the value has changed by the time we commit the hydration. That way you can reflect the new value in state to bring it in sync. It does this whether controlled or uncontrolled.  The idea is that this should be ok to replay because it's similar to the continuous events in that it doesn't replay a sequence but only reflects the current state of the tree.  Since this is a breaking change I added it behind `enableHydrationChangeEvent` flag.  There is still an additional issue remaining that I intend to address in a follow up. If a `useLayoutEffect` triggers an sync rerender on hydration (always a bad idea) then that can rerender before we have had a chance to replay the change events. If that renders through a input then that input will always override the browser value with the controlled value. Which will reset it before we've had a change to update to the new value.",419,64,483
facebook/react,79586c7eb626c6b9362c308a54c9ee5b66e640e5,Matt Carroll,2025-05-05T21:47:47Z,Add test for multiple form submissions (#33059)  Test for #30041 and #33055,31,0,31
facebook/react,edf550b67936f2c62534ad5549bf580a4f581bd8,Jack Pope,2025-05-05T17:36:44Z,Ship enableFabricCompleteRootInCommitPhase (#33064)  This was shipped internally. Cleaning up the flag.,2,20,22
facebook/react,b9cfa0d3083f80bdd11ba76a55aa08fa659b7359,"Sebastian ""Sebbie"" Silbermann",2025-05-05T16:30:33Z,[Flight] Prevent serialized size leaking across requests (#33121),49,12,61
facebook/react,c129c2424b662a371865a0145c562a1cf934b023,mofeiZ,2025-05-05T15:52:45Z,[compiler][repro] Nested fbt test fixture (#32779)  Ideally we should detect and bail out on this case to avoid babel build failures.,94,0,94
facebook/react,0c1575cee8a78dd097edcafc307522ad000e372c,mofeiZ,2025-05-05T15:45:58Z,"[compiler][bugfix] Bail out when a memo block declares hoisted fns (#32765)  Note that bailing out adds false positives for hoisted functions whose only references are within other functions. For example, this rewrite would be safe. ```js // source program   function foo() {     return bar();   }   function bar() {     return 42;   }  // compiler output let bar; if (/* deps changed */) {   function foo() {     return bar();   }   bar = function bar() {     return 42;   } } ``` These false positives are difficult to detect because any maybe-call of foo before the definition of bar would be invalid.  Instead of bailing out, we should rewrite hoisted function declarations to the following form. ```js let bar$0; if (/* deps changed */) {   // All references within the declaring memo block   // or before the function declaration should use   // the original identifier `bar`   function foo() {     return bar();   }   function bar() {     return 42;   }   bar$0 = bar; } // All references after the declaring memo block // or after the function declaration should use // the rewritten declaration `bar$0` ```",206,83,289
facebook/react,52ea641449570bbc32eb90fb1a76740249b6bcf5,Sebastian Markbåge,2025-05-05T15:37:39Z,[Flight] Don't increase serializedSize for every recursive pass (#33123)  I noticed that we increase this in the recursive part of the algorithm. This would mean that we'd count a key more than once if it has Server Components inside it recursively resolving. This moves it out to where we enter from toJSON. Which is called once per JSON entry (and therefore once per key).,3,2,5
facebook/react,3ec88e797f7352c87cb79292b02fdfc53050133f,Stephen Zhou,2025-05-05T15:37:06Z,[eslint-plugin-react-hooks] update doc url for rules of hooks (#33118),1,1,2
facebook/react,0ca8420f9d051285c452a590ac4a4c9476406bef,"Sebastian ""Sebbie"" Silbermann",2025-05-04T11:47:32Z,[Flight] Use valid CSS selectors in `useId` format (#33099),13,7,20
facebook/react,0db8db178c1521f979535bdba32bf9db9f47ca05,Joe Savona,2025-05-03T00:15:32Z,"[compiler] Validate against mutable functions being frozen  This revisits a validation I built a while ago, trying to make it more strict this time to ensure that it's high-signal.  We detect function expressions which are *known* mutable — they definitely can modify a variable defined outside of the function expression itself (modulo control flow). This uses types to look for known Store and Mutate effects only, and disregards mutations of effects. Any such function passed to a location with a Freeze effect is reported as a validation error.  This is behind a flag and disabled by default. If folks agree this makes sense to revisit, i'll test out internally and we can consider enabling by default.  ghstack-source-id: 075a731444ce95e52dbd5ea3be85c16d428927f5 Pull Request resolved: https://github.com/facebook/react/pull/33079",266,0,266
facebook/react,8570116bd1ba872537132de42b997ec56c726659,Joe Savona,2025-05-03T00:15:32Z,"[compiler] Fix for uncalled functions that are known-mutable  If a function captures a mutable value but never gets called, we don't infer a mutable range for that function. This means that we also don't alias the function with its mutable captures.  This case is tricky, because we don't generally know for sure what is a mutation and what may just be a normal function call. For example:  ```js hook useFoo() {   const x = makeObject();   return () => {     return readObject(x); // could be a mutation!   } } ```  If we pessimistically assume that all such cases are mutations, we'd have to group lots of memo scopes together unnecessarily. However, if there is definitely a mutation:  ```js hook useFoo(createEntryForKey) {   const cache = new WeakMap();   return (key) => {     let entry = cache.get(key);     if (entry == null) {       entry = createEntryForKey(key);       cache.set(key, entry); // known mutation!     }     return entry;   } } ```  Then we have to ensure that the function and its mutable captures alias together and end up in the same scope. However, aliasing together isn't enough if the function and operands all have empty mutable ranges (end = start + 1).  This pass finds function expressions and object methods that have an empty mutable range and known-mutable operands which also don't have a mutable range, and ensures that the function and those operands are aliased together *and* that their ranges are updated to end after the function expression. This is sufficient to ensure that a reactive scope is created for the alias set.  NOTE: The alternative is to reject these cases. If we do that we'd also want to similarly disallow cases like passing a mutable function to a hook.  ghstack-source-id: 5d8158246a320e80d8da3f0e395ac1953d8920a2 Pull Request resolved: https://github.com/facebook/react/pull/33078",251,0,251
facebook/react,4f1d2ddf95906e9a3436552c524410e9d39f48ca,Joe Savona,2025-05-03T00:15:32Z,"[compiler] Add types for WeakMap, WeakSet, and reanimated shared values  Building on mofeiz's recent work to type constructors. Also, types for reanimated values which are useful in the next PR.  ghstack-source-id: 1c81e213a11337ac7e9c85a429ecf3f1d1adef66 Pull Request resolved: https://github.com/facebook/react/pull/33077",570,1,571
facebook/react,73d7e816b7746c700ab843964aaf11c17351fac1,Joe Savona,2025-05-03T00:09:34Z,"[compiler] ValidatePreservedManualMemoization reports detailed errors  This pass didn't previously report the precise difference btw inferred/manual dependencies unless a debug flag was set. But the error message is really good (nice job mofeiz): the only catch is that in theory the inferred dep could be a temporary that can't trivially be reported to the user.  But the messages are really useful for quickly verifying why the compiler couldn't preserve memoization. So here we switch to outputting a detailed message about the discrepancy btw inferred/manual deps so long as the inferred dep root is a named variable. I also slightly adjusted the message to handle the case where there is no diagnostic, which can occur if there were no manual deps but the compiler inferred a dependency.  ghstack-source-id: 534f6f1fec0855e05e85077eba050eb2ba254ef8 Pull Request resolved: https://github.com/facebook/react/pull/33095",42,39,81
facebook/react,ac2cae524576b8091a6d78d9ab05627053949df1,Joe Savona,2025-05-03T00:07:50Z,"[compiler] Fix for string attribute values with emoji  If a JSX attribute value is a string that contains unicode or other characters that need special escaping, we wrap the attribute value in an expression container. However, our unicode to detect this only handled the basic unicode character plane, not the ""astral"" plane which includes emojis.  This PR updates the regex to detect such extended characters and also use an expression container.  ghstack-source-id: 6d9c8e4dd22285077108e2fa53d66154d1b781fb Pull Request resolved: https://github.com/facebook/react/pull/33096",8,2,10
facebook/react,66de8e5a9975a4b53734ebed8a1c1f07892426a8,Jan Kassens,2025-05-02T22:14:56Z,[eslint-plugin-react-hooks] move eslint plugin once again (#33110),2,1,3
facebook/react,26ecc98a0014700524e78d938e3654c73213cf3b,lauren,2025-05-02T21:50:39Z,"[mcp] Prompt improvements for smarter tool composition (#33108)  Our runtime results are still bogus, but so far this tweak let's the llm use the tools a little more intelligently.  example: ---  ```js import React from 'react';  function App() {   const [count, setCount] = React.useState(0);   const [data, setData] = React.useState([]);    React.useEffect(() => {     const processData = () => {       console.log(""Processing data..."");       const newData = [];       for (let i = 0; i < 1000000000; i++) {         newData.push({ id: i, value: Math.random() * count });       }       return newData;     };      const processedData = processData();     setData(processedData);   }, [count]);    return (     <div>       <p>Count: {count}</p>       <p>Data Length: {data.length}</p>       <ul>         {data.slice(0, 5).map((item) => (           <li key={item.id}>Item {item.id}: {item.value.toFixed(2)}</li>         ))}       </ul>     </div>   ); }; ``` why is this component slow? use the react tools to figure this out.  > I'll analyze why this component is slow using the React tools. Let's first evaluate the performance of the original code. > [review-react-runtime ...] > > The performance measurement tool timed out, which is a strong indication of just how severe the performance issue is in this component. Let's now try to compile the code to see if React Compiler can identify any issues: > [compile...] > > Now I understand the issue. Let's analyze why this component > is extremely slow: > Main Performance Issues: > > Massive Data Processing: The component is trying to create an array with a billion (1,000,000,000) objects in the processData function. This is an enormous amount of data that will: > > Consume massive amounts of memory > Take an extremely long time to process > Likely crash the browser > > > Unnecessary Recalculation: The effect depends on [count], meaning every time the count changes, it will reprocess this enormous dataset. > Inefficient Data Handling: Even though only 5 items are displayed, the component processes a billion items. > > Let's fix these issues: > [compile...] > > Now let's check if our modified code performs better: > [review-react-runtime...] > > Excellent! The performance has dramatically improved. Now let's check the React documentation to make sure we're following the best practices: > [query-react-dev-docs...]  (hit the maximum length conversation limit because i'm on a free plan)",14,5,19
facebook/react,f0ca53d1337780ccfd49c132170d378c789cb463,Jan Kassens,2025-05-02T21:05:56Z,"[eslint-plugin-react-hooks] another CI update... (#33107)  We currently created a nested directory, this should remove that.  See:  https://github.com/facebook/react/tree/builds/facebook-fbsource/compiled-rn/facebook-fbsource/xplat/js/RKJSModules/vendor/react/eslint-plugin-react-hooks/eslint-plugin-react-hooks",1,3,4
facebook/react,e39b380a21aa4ef48d5880aa2c800ec5b1b044bd,lauren,2025-05-02T20:54:17Z,[mcp] Fix unresolved imports (#33105)  We need to explicitly import the modules so they'll be inlined correctly into the bundle.,8,6,14
facebook/react,9de0304ad72bc3f8a77d2d84efa530b8051d1c15,Jan Kassens,2025-05-02T20:52:17Z,Add missing copyright header (#33106)  This made the build fail since there was no file header comment.,14,0,14
facebook/react,0d695bea10c04d32df4fae7813aa5f448213014a,Jan Kassens,2025-05-02T20:03:06Z,"[eslint-plugin-react-hooks] update fbsource build (#33104)  In order to sync the lint rules directly to internal, include the eslint plugin in the build output for fbsource.",9,2,11
facebook/react,4c4a57c4f9f7f7d44e4cbe868c066e3691cd4038,Jan Kassens,2025-05-02T19:04:45Z,[eslint-plugin-react-hooks] updates for component syntax (#33089)  Adds support for Flow's component and hook syntax. [docs](https://flow.org/en/docs/react/component-syntax/),3152,11,3163
facebook/react,dc2b11817bbfcd39f1dbdc8945acbf18cb5e41c3,lauren,2025-05-02T18:15:12Z,"[mcp] Refactor (#33085)  Just some cleanup. Mainly, we now take the number of iterations as an argument. Everything else is just code movement and small tweaks.",243,214,457
facebook/react,b5450b07389b5d64841ef2998561f25fc11c066a,lauren,2025-05-02T18:06:20Z,[mcp] Update prompts (#33084)  Some tweaks to the prompt to provide more context on how to use them. --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33084). * #33085 * __->__ #33084 * #33083,26,7,33
facebook/react,f150c046ec8bd91d37a260614c53459a131ab92f,lauren,2025-05-02T18:06:11Z,[mcp] Move to /tools (#33083)  Moves to a tools directory. --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33083). * #33085 * #33084 * __->__ #33083,1,1,2
facebook/react,12b094d2f66b48c0b34cdfdf997fefac373d47a8,lauren,2025-05-02T17:56:45Z,[mcp] Update plugins (#33082)  Adds typescript support. --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33082). * #33085 * #33084 * #33083 * __->__ #33082 * #33101,3,2,5
facebook/react,e5f0315efa60a76332b32f21e495e36b26bdd36e,lauren,2025-05-02T17:56:01Z,[mcp] Fix package.json (#33101)  Since we use esbuild we need to correctly move dependencies that are required at runtime into `dependencies` and other packages that are only used in development in to `devDependencies`. This ensures the correct packages are included in the build. --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33101). * #33085 * #33084 * #33083 * #33082 * __->__ #33101,270,88,358
facebook/react,f739642745577a8e4dcb9753836ac3589b9c590a,Sebastian Markbåge,2025-05-01T22:14:42Z,"[Fizz] Always load the external runtime if one is provided (#33091)  Because we now decided whether to outline in the flushing phase, when we're writing the preamble we don't yet know if we will make that decision so we don't know if it's safe to omit the external runtime.  However, if you are providing an external runtime it's probably a pretty safe bet you're streaming something dynamically that's likely to need it so we can always include it.  The main thing is that this makes it hard to test it because it affects our tests in ways it wouldn't otherwise so we have to add a bunch of conditions.",26,24,50
facebook/react,0ed6ceb9f6c19f28c504cf46193cef40166a61f6,Sebastian Markbåge,2025-05-01T20:11:54Z,"[Fizz] Add ""Queued"" Status to SSR:ed Suspense Boundaries (#33087)  Stacked on #33076.  This fixes a bug where we used the ""complete"" status but the DOMContentLoaded event. This checks for not ""loading"" instead.  We also add a new status where the boundary has been marked as complete by the server but has not yet flushed either due to being throttled, suspended on CSS or animating.",42,15,57
facebook/react,ee7fee8f8875052afde53c5bfc8aedad43ff9d8e,Sebastian Markbåge,2025-05-01T20:09:37Z,"[Fizz] Batch Suspense Boundary Reveal with Throttle (#33076)  Stacked on #33073.  React semantics is that Suspense boundaries reveal with a throttle (300ms). That helps avoid flashing reveals when a stream reveals many individual steps back to back. It can also improve overall performance by batching the layout and paint work that has to happen at each step.  Unfortunately we never implemented this for SSR streaming - only for client navigations. This is highly noticeable on very dynamic sites with lots of Suspense boundaries. It can look good with a client nav but feel glitchy when you reload the page or initial load.  This fixes the Fizz runtime to be throttled and reveals batched into a single paint at a time. We do this by first tracking the last paint after the complete (this will be the first paint if `rel=""expect""` is respected). Then in the `completeBoundary` operation we queue the operation and then flush it all into a throttled batch.  Another motivation is that View Transitions need to operate as a batch and individual steps get queued in a sequence so it's extra important to include as much content as possible in each animated step. This will be done in a follow up for SSR View Transitions.",220,67,287
facebook/react,ee077b6ccddd916440bb7570ba6f53673d920700,Sebastian Markbåge,2025-05-01T19:44:17Z,"[Fizz] Don't handle errors in completeBoundary instruction (#33073)  Stacked on #33066 and #33068.  Currently we're passing `errorDigest` to `completeBoundary` if there is a client side error (only CSS loading atm). This only exists because of `completeBoundaryWithStyles`. Normally if there's a server-side error we'd emit the `clientRenderBoundary` instruction instead. This adds unnecessary code to the common case where all styles are in the head. This is about to get worse with batching because client render shouldn't be throttled but complete should be.  The first commit moves the client render logic inline into `completeBoundaryWithStyles` so we only pay for it when styles are used.  However, the approach I went with in the second commit is to reuse the `$RX` instruction instead (`clientRenderBoundary`). That way if you have both it ends up being amortized. However, it does mean we have to emit the `$RX` (along with the `$RC` helper if any `completeBoundaryWithStyles` instruction is needed.",63,64,127
facebook/react,bb57fa7351776a86448c1a094bea8108fd6b34ff,Sebastian Markbåge,2025-05-01T18:25:10Z,"[Fizz] Share code between inline and external runtime (#33066)  Stacked on #33065.  The runtime is about to be a lot more complicated so we need to start sharing some more code.  The problem with sharing code is that we want the inline runtime to as much as possible be isolated in its scope using only a few global variables to refer across runtimes.  A problem with Closure Compiler is that it refuses to inline functions if they have closures inside of them. Which makes sense because of how VMs work it can cause memory leaks. However, in our cases this doesn't matter and code size matters more. So we can't use many clever tricks.  So this just favors writing the source in the inline form. Then we add an extra compiler pass to turn those global variables into local variables in the external runtime.",190,291,481
facebook/react,e9db3cc2d4175849578418a37f33a6fde5b3c6d8,Joe Savona,2025-05-01T03:41:26Z,"[compiler] PruneNonEscapingScopes understands terminal operands  We weren't treating terminal operands as eligible for memoization in PruneNonEscapingScopes, which meant that they could end up un-memoized. Terminal operands can also be compound ReactiveValues like SequenceExpressions, so part of the fix is to make sure we don't just recurse into compound values but record the full aliasing information we would for top-level instructions.  Still WIP, this needs to handle terminals other than for..of.  ghstack-source-id: 09a29230514e3bc95d1833cd4392de238fabbeda Pull Request resolved: https://github.com/facebook/react/pull/33062",681,468,1149
facebook/react,d8074cbc798a500a5e76d19fe0c17edec22b2593,Jorge Cabiedes,2025-04-30T22:42:00Z,"[mcp] Make tool more reliable and fix integration issues with babel (#33074)  ## Summary  Fix babel presets, and add a bit more context to the tool so that it is more reliable  ## How did you test this change?  Manually tested the mcp integrated with claude desktop",48,50,98
facebook/react,71797c871b6bfa45988cba38f3388bac095b26cf,Sebastian Markbåge,2025-04-30T21:51:39Z,"[Fizz] Ignore error if content node is gone (#33068)  We normally expect the segment to exist whatever the client does while streaming. However, when hydration errors at the root of the shell for a whole document render, then we clear nodes from body which can include our segments. We don't need them anymore because we switched to client rendering.  It triggers an error accessing parent node which can safely be ignored. This just helps avoid confusion in this scenario.  This also covers up the error in #33067. Which doesn't actually cause any visible problems other than error logging. However, ideally we wouldn't emit completeBoundary instructions if the boundary is inside a cancelled fallback.",7,1,8
facebook/react,9d795d3808f3202b36740a7a8eb60567bd7f6d90,mofeiZ,2025-04-30T21:18:58Z,"[compiler][bugfix] expand StoreContext to const / let / function variants (#32747)  ```js function Component() {   useEffect(() => {     let hasCleanedUp = false;     document.addEventListener(..., () => hasCleanedUp ? foo() : bar());     // effect return values shouldn't be typed as frozen     return () => {       hasCleanedUp = true;     }   }; } ``` ### Problem `PruneHoistedContexts` currently strips hoisted declarations and rewrites the first `StoreContext` reassignment to a declaration. For example, in the following example, instruction 0 is removed while a synthetic `DeclareContext let` is inserted before instruction 1.  ```js // source const cb = () => x; // reference that causes x to be hoisted  let x = 4; x = 5;  // React Compiler IR [0] DeclareContext HoistedLet 'x' ... [1] StoreContext reassign 'x' = 4 [2] StoreContext reassign 'x' = 5 ```  Currently, we don't account for `DeclareContext let`. As a result, we're rewriting to insert duplicate declarations. ```js // source const cb = () => x; // reference that causes x to be hoisted  let x; x = 5;  // React Compiler IR [0] DeclareContext HoistedLet 'x' ... [1] DeclareContext Let 'x' [2] StoreContext reassign 'x' = 5 ```  ### Solution  Instead of always lowering context variables to a DeclareContext followed by a StoreContext reassign, we can keep `kind: 'Const' | 'Let' | 'Reassign' | etc` on StoreContext. Pros: - retain more information in HIR, so we can codegen easily `const` and `let` context variable declarations back - pruning hoisted `DeclareContext` instructions is simple.  Cons: - passes are more verbose as we need to check for both `DeclareContext` and `StoreContext` declarations  ~(note: also see alternative implementation in https://github.com/facebook/react/pull/32745)~  ### Testing Context variables are tricky. I synced and diffed changes in a large meta codebase and feel pretty confident about landing this. About 0.01% of compiled files changed. Among these changes, ~25% were [direct bugfixes](https://www.internalfb.com/phabricator/paste/view/P1800029094). The [other changes](https://www.internalfb.com/phabricator/paste/view/P1800028575) were primarily due to changed (corrected) mutable ranges from https://github.com/facebook/react/pull/33047. I tried to represent most interesting changes in new test fixtures  `",916,232,1148
facebook/react,12f4cb85c5847758ece81fc95b7eaedc1fb9ebd0,mofeiZ,2025-04-30T19:50:54Z,[compiler][bugfix] Returned functions are not always frozen (#33047)  Fixes an edge case in React Compiler's effects inference model.  Returned values should only be typed as 'frozen' if they are (1) local and (2) not a function expression which may capture and mutate this function's outer context. See test fixtures for details --- [//]: # (BEGIN SAPLING FOOTER) Stack created with [Sapling](https://sapling-scm.com). Best reviewed with [ReviewStack](https://reviewstack.dev/facebook/react/pull/33047). * #32765 * #32747 * __->__ #33047,293,4,297
facebook/react,90a124a9802a5ab6509d5838e65b9f4d4fbbc16b,Jorge Cabiedes,2025-04-30T19:44:05Z,"[mdn] Initial experiment for adding performance tool (#33045)  ## Summary Add a way for the agent to get some data on the performance of react code  ## How did you test this change? Tested function independently and directly with claude desktop app  ---------  Co-authored-by: Sebastian ""Sebbie"" Silbermann <sebastian.silbermann@vercel.com>",3048,2482,5530
facebook/react,49ea8bf5698f017022517be79f5f53e6f6a4dad3,Sebastian Markbåge,2025-04-30T18:21:28Z,"[Flight] Defer Elements if the parent chunk is too large (#33030)  Same principle as #33029 but for Flight.  We pretty aggressively create separate rows for things in Flight (every Server Component that's an async function create a microtask). However, sync Server Components and just plain Host Components are not. Plus we should ideally ideally inline more of the async ones in the same way Fizz does.  This means that we can create rows that end up very large. Especially if all the data is already available. We can't show the parent content until the whole thing loads on the client.  We don't really know where Suspense boundaries are for Flight but any Element is potentially a point that can be split.  This heuristic counts roughly how much we've serialized to block the current chunk and once a limit is exceeded, we start deferring all Elements. That way they get outlined into future chunks that are later in the stream. Since they get replaced by Lazy references the parent can potentially get unblocked.  This can help if you're trying to stream a very large document with a client nav for example.",162,3,165
facebook/react,9a52ad9fd9c6211d056942a455435c2804869854,Sebastian Markbåge,2025-04-30T18:21:14Z,[Fizz] Remove globals from external runtime (#33065)  We never emit any inline functions when we use external runtime so this global shouldn't be needed.,0,7,7
facebook/react,fa8e3a251e7840fa220a1649dec616e72658473e,"Sebastian ""Sebbie"" Silbermann",2025-04-30T17:51:40Z,[devtools] Restore all Transitions for Tree updates (#33042),50,9,59
facebook/react,408d055a3b89794088130ed39bf42ca540766275,Jack Pope,2025-04-30T14:47:18Z,"Add Fragment Refs to Fabric with intersection observer support (#33056)  Adds Fragment Ref support to RN through the Fabric config, starting with `observeUsing`/`unobserveUsing`. This is mostly a copy from the implementation on DOM, and some of it can likely be shared in the future but keeping it separate for now and we can refactor as we add more features.  Added a basic test with Fabric, but testing specific methods requires so much mocking that it doesn't seem valuable here.  I built Fabric and ran on the Catalyst app internally to test with intersection observers end to end.",159,12,171
facebook/react,fbf29ccaa3598c6443d8d550aa406f9c6f654076,"Sebastian ""Sebbie"" Silbermann",2025-04-30T09:11:33Z,"[devtools] Restore ""double-click to view owners tree"" functionality (#33039)",11,8,19
facebook/react,62960c67c84da7e85d7515ef8447cea0ba0824a6,Sebastian Markbåge,2025-04-30T02:17:17Z,"Run Component Track Logs in the console.createTask() of the Fiber (#32809)  Stacked on #32736.  That way you can find the owner stack of each component that rerendered for context.  In addition to the JSX callsite tasks that we already track, I also added tracking of the first `setState` call before rendering.  We then run the ""Update"" entries in that task. That way you can find the callsite of the first setState and therefore the ""cause"" of a render starting by selecting the ""Update"" track.  Unfortunately this is blocked on bugs in Chrome that makes it so that these stacks are not reliable in the Performance tab. It basically just doesn't work.",358,113,471
